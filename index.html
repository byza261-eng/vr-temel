<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HaritaGÃ¶z - TÃ¼rkiye KatmanlÄ± VR SimÃ¼latÃ¶r</title>

  <!-- Leaflet (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    :root{
      --bg1:#0f1f2c; --bg2:#1a3343;
      --card: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.12);
      --green:#4CAF50; --amber:#FFC107; --blue:#2196F3; --red:#F44336;
    }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color:#fff;
      overflow-x:hidden;
      -webkit-text-size-adjust:100%;
    }

    /* Header */
    .header{
      position: sticky;
      top:0;
      z-index: 20;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,0.12);
      padding: 14px 14px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .logo{
      display:flex; align-items:center; gap:10px;
      font-weight:800; font-size:20px; color: var(--green);
      white-space:nowrap;
    }

    .header-right{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding: 8px 10px;
      display:flex; gap:8px; align-items:center;
      font-size:13px;
    }
    .pill b{ color: var(--amber); font-size:14px; }
    .btn{
      border:none; cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:800;
      color:#fff;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      transition: transform .12s ease, background .12s ease;
      touch-action: manipulation;
    }
    .btn:active{ transform: scale(0.98); }
    .btn-primary{ background: linear-gradient(135deg, var(--green), #8BC34A); border:none; }
    .btn-blue{ background: linear-gradient(135deg, #1e88e5, #42a5f5); border:none; }
    .btn-warn{ background: linear-gradient(135deg, #ff9800, #ffb300); border:none; color:#222; }
    .btn-danger{ background: linear-gradient(135deg, #e53935, #ff5252); border:none; }
    .btn-small{ padding:8px 10px; font-size:13px; }

    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px 12px 28px;
    }

    .section{
      background: var(--card);
      border:1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      margin: 14px 0;
      backdrop-filter: blur(10px);
    }

    .section-title{
      display:flex; align-items:center; gap:10px;
      color: var(--green);
      font-size: 20px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    /* Map frame (normal mode) */
    .map-frame{
      border-radius: 16px;
      overflow:hidden;
      border: 2px solid rgba(76,175,80,0.45);
      background:#0b1218;
    }
    #mapNormal{
      width:100%;
      height: 56vh;
      min-height: 380px;
    }

    .controls{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }

    .layerbar{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    .layer-btn{
      border:none;
      padding: 12px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 900;
      font-size: 14px;
      display:flex;
      align-items:center;
      gap:8px;
      touch-action: manipulation;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, filter .12s ease, opacity .12s ease;
    }
    .layer-btn:active{ transform: scale(0.98); }
    .layer-btn.off{ opacity:0.55; filter: grayscale(0.85); }
    .layer-topo{ background: linear-gradient(135deg, #6d4c41, #d2691e); color:#fff; }
    .layer-osm{ background: linear-gradient(135deg, #ffd54f, #ffb300); color:#222; }
    .layer-water{ background: linear-gradient(135deg, #1e88e5, #1565c0); color:#fff; }
    .layer-settle{ background: linear-gradient(135deg, #ff7043, #f4511e); color:#fff; }
    .layer-risk{ background: linear-gradient(135deg, #d32f2f, #7f0000); color:#fff; }

    /* Extra panels */
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 860px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .card{
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 12px;
    }
    .card h3{ font-size:16px; margin-bottom:8px; color:#e8f5e9; }
    .muted{ color: rgba(255,255,255,0.75); font-size: 13px; line-height: 1.45; }

    /* ===== VR MODE OVERLAY ===== */
    body.vr-lock{
      overflow: hidden;
      position: fixed;
      width:100%;
      height:100%;
      inset:0;
      touch-action:none;
    }

    #vrOverlay{
      position: fixed;
      inset:0;
      z-index: 9999;
      background: #000;
      display:none;
    }
    #vrOverlay.on{ display:block; }

    /* two-eye layout */
    .vr-stage{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction: row;
      width:100%;
      height:100%;
    }
    .eye{
      position: relative;
      width:50%;
      height:100%;
      overflow:hidden;
      background:#000;
    }
    .eye .map{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }

    /* VR HUD (must be clickable) */
    .vr-hud{
      position:absolute;
      top: env(safe-area-inset-top, 10px);
      left: 0;
      right:0;
      padding: 10px 10px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center;
      pointer-events: auto;   /* IMPORTANT */
      z-index: 50;
    }
    .vr-hud .btn, .vr-hud .layer-btn{
      pointer-events:auto;     /* IMPORTANT */
    }

    .vr-bottom{
      position:absolute;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      left:0; right:0;
      display:flex;
      justify-content:center;
      gap:10px;
      z-index: 50;
      padding: 0 10px;
      pointer-events:auto;
    }

    .hint{
      position:absolute;
      left:12px;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 60px);
      z-index: 60;
      background: rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.18);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.9);
      max-width: 70ch;
      pointer-events:none;
    }

    /* orientation hint */
    #rotateHint{
      display:none;
      position:absolute;
      inset:0;
      z-index: 100;
      background: rgba(0,0,0,0.85);
      color:#fff;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 20px;
      font-weight:900;
      font-size: 18px;
    }
    #rotateHint.on{ display:flex; }

    /* Leaflet tweaks */
    .leaflet-control-attribution { font-size: 10px; }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">ğŸ—ºï¸ HaritaGÃ¶z</div>

    <div class="header-right">
      <div class="pill">Puan: <b id="score">0</b></div>
      <div class="pill">Seviye: <b id="level">1</b></div>

      <button class="btn btn-small" id="bepBtn">BEP Modu</button>
      <button class="btn btn-blue btn-small" id="vrBtn">ğŸ¥½ VR Modu</button>
    </div>
  </div>

  <div class="container">
    <div class="section">
      <div class="section-title">ğŸ¯ TÃ¼rkiye KatmanlÄ± Harita (Normal Mod)</div>

      <div class="map-frame">
        <div id="mapNormal"></div>
      </div>

      <div class="controls">
        <div class="layerbar" id="layerBar">
          <button class="layer-btn layer-topo" data-layer="topo">ğŸ”ï¸ Topografya</button>
          <button class="layer-btn layer-osm" data-layer="osm">ğŸ›£ï¸ Yollar/Harita</button>
          <button class="layer-btn layer-water" data-layer="water">ğŸ’§ Su</button>
          <button class="layer-btn layer-settle" data-layer="settle">ğŸ˜ï¸ YerleÅŸim</button>
          <button class="layer-btn layer-risk" data-layer="risk">âš ï¸ Risk</button>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn btn-primary" id="centerTR">ğŸ‡¹ğŸ‡· TÃ¼rkiyeâ€™ye Ortala</button>
          <button class="btn" id="resetUI">SÄ±fÄ±rla</button>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">ğŸ“Œ Notlar</div>
      <div class="grid2">
        <div class="card">
          <h3>Katmanlar neden aÃ§Ä±lmÄ±yordu?</h3>
          <div class="muted">
            VRâ€™de genelde Ã¼stteki katman â€œtÄ±klamayÄ± yutarâ€. Bu sÃ¼rÃ¼mde HUD ve butonlarda
            <b>pointer-events:auto</b> zorlandÄ± ve iOS iÃ§in <b>pointerdown/touchstart</b> ile gÃ¼vence alÄ±ndÄ±.
          </div>
        </div>
        <div class="card">
          <h3>Bluetooth kumanda</h3>
          <div class="muted">
            Ok tuÅŸlarÄ±yla katmanlar arasÄ±nda gezebilir, <b>Enter / Space</b> ile aÃ§-kapat yapabilirsin.
            AyrÄ±ca tarayÄ±cÄ± desteklerse <b>Gamepad API</b> ile de yakalanÄ±r.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- VR Overlay -->
  <div id="vrOverlay" aria-hidden="true">
    <div id="rotateHint">ğŸ“± Telefonu yatay Ã§evir (VR iÃ§in)</div>

    <div class="vr-stage" id="vrStage">
      <div class="eye">
        <div class="map" id="mapLeft"></div>
      </div>
      <div class="eye">
        <div class="map" id="mapRight"></div>
      </div>

      <div class="vr-hud" id="vrHud">
        <button class="layer-btn layer-topo" data-layer="topo">ğŸ”ï¸</button>
        <button class="layer-btn layer-osm" data-layer="osm">ğŸ›£ï¸</button>
        <button class="layer-btn layer-water" data-layer="water">ğŸ’§</button>
        <button class="layer-btn layer-settle" data-layer="settle">ğŸ˜ï¸</button>
        <button class="layer-btn layer-risk" data-layer="risk">âš ï¸</button>

        <button class="btn btn-warn" id="motionBtn">ğŸ› BaÅŸ Ä°zleme Ä°zni</button>
        <button class="btn btn-danger" id="vrCloseBtn">âœ– VR Kapat</button>
      </div>

      <div class="vr-bottom">
        <button class="btn" id="zoomOut">â– Zoom</button>
        <button class="btn" id="zoomIn">â• Zoom</button>
        <button class="btn btn-primary" id="centerTR2">ğŸ‡¹ğŸ‡· Ortala</button>
      </div>

      <div class="hint" id="vrHint">
        âŒ¨ï¸ / ğŸ® Kumanda: Ok tuÅŸlarÄ± = katman seÃ§, Enter/Space = aÃ§-kapat. <br/>
        ğŸ‘† Dokunarak da aÃ§abilirsin. BaÅŸ izleme iÃ§in â€œBaÅŸ Ä°zleme Ä°zniâ€ne bas.
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    /**************
     * STATE
     **************/
    const state = {
      score: 0,
      level: 1,
      bep: false,

      // layers on/off
      layers: { topo:true, osm:true, water:false, settle:false, risk:false },

      // VR
      vrOn: false,
      activeLayerIndex: 0,
      layerOrder: ["topo","osm","water","settle","risk"],

      // head tracking
      motionEnabled: false,
      yaw: 0,
      pitch: 0,
      lastPanTs: 0
    };

    const $ = (id)=>document.getElementById(id);

    function addScore(p){
      state.score += p;
      const newLevel = Math.floor(state.score / 200) + 1;
      if(newLevel > state.level) state.level = newLevel;
      $("score").textContent = state.score;
      $("level").textContent = state.level;
    }

    /**************
     * MAP LAYERS (Real tiles)
     **************/
    const trCenter = [39.0, 35.0];
    const trZoom = 6;

    // Normal map
    const mapNormal = L.map("mapNormal", { zoomControl: true, preferCanvas:true })
      .setView(trCenter, trZoom);

    // VR maps (created on demand)
    let mapLeft = null;
    let mapRight = null;

    // Tile layers
    // Topography: OpenTopoMap (real topo look)
    const topoURL = "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png";
    const topoAttr = 'Map data: Â© OpenStreetMap contributors, SRTM | Map style: Â© OpenTopoMap';
    function makeTopo(){ return L.tileLayer(topoURL, { maxZoom: 17, attribution: topoAttr, opacity: 0.92 }); }

    // Roads/Map: OSM standard tiles
    const osmURL = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
    const osmAttr = 'Â© OpenStreetMap contributors';
    function makeOSM(){ return L.tileLayer(osmURL, { maxZoom: 19, attribution: osmAttr, opacity: 0.70 }); }

    // Extra overlays (water lines, settlement points, risk polygons)
    function makeWaterOverlay(map){
      const group = L.layerGroup();
      // A few example rivers-ish lines in Turkey for demo (not perfect GIS, but gives a water emphasis layer)
      const lines = [
        [[40.9, 29.1],[41.2, 31.2],[41.0, 33.0],[41.0, 35.0],[41.1, 37.0]],
        [[39.9, 32.9],[39.3, 34.8],[38.8, 36.6],[37.9, 38.7],[37.0, 39.2]],
        [[38.7, 26.9],[38.8, 28.2],[38.6, 29.6],[38.3, 30.5]]
      ];
      lines.forEach(path=>{
        L.polyline(path, { color:"#2aa7ff", weight: 4, opacity: 0.75 }).addTo(group);
      });
      // A few lake markers
      const lakes = [
        {name:"Tuz GÃ¶lÃ¼", lat:38.8, lng:33.3},
        {name:"Van GÃ¶lÃ¼", lat:38.6, lng:42.9},
        {name:"BeyÅŸehir", lat:37.7, lng:31.7},
      ];
      lakes.forEach(l=>{
        L.circle([l.lat,l.lng], { radius: 30000, color:"#2aa7ff", fillColor:"#2aa7ff", fillOpacity:0.25, weight:2 })
          .bindTooltip("ğŸ’§ "+l.name)
          .addTo(group);
      });
      return group;
    }

    function makeSettlementOverlay(map){
      const group = L.layerGroup();
      const cities = [
        ["Ä°stanbul",41.0082,28.9784],
        ["Ankara",39.9334,32.8597],
        ["Ä°zmir",38.4237,27.1428],
        ["Bursa",40.1950,29.0600],
        ["Antalya",36.8969,30.7133],
        ["Adana",37.0000,35.3213],
        ["Gaziantep",37.0662,37.3833],
        ["Konya",37.8715,32.4846],
        ["Kayseri",38.7225,35.4875],
        ["Trabzon",41.0015,39.7178],
        ["DiyarbakÄ±r",37.9144,40.2306],
        ["Samsun",41.2867,36.3300],
      ];
      cities.forEach(([name,lat,lng])=>{
        L.circleMarker([lat,lng], {
          radius: 7,
          color:"#ffcc80",
          fillColor:"#ff6d00",
          fillOpacity: 0.75,
          weight:2
        }).bindTooltip("ğŸ˜ï¸ "+name).addTo(group);
      });
      return group;
    }

    function makeRiskOverlay(map){
      const group = L.layerGroup();

      // Example risk zones (demo polygons)
      const flood = L.polygon(
        [[41.35, 28.65],[41.45, 29.25],[41.20, 29.35],[41.10, 28.85]],
        { color:"#ff9800", fillColor:"#ff9800", fillOpacity:0.22, weight:2 }
      ).bindTooltip("ğŸŸ  Sel Riski (Ã¶rnek)");

      const landslide = L.polygon(
        [[40.95, 39.25],[41.20, 39.95],[40.75, 40.35],[40.55, 39.70]],
        { color:"#ff1744", fillColor:"#ff1744", fillOpacity:0.22, weight:2 }
      ).bindTooltip("ğŸ”´ Heyelan Riski (Ã¶rnek)");

      const seismic = L.polygon(
        [[38.7, 26.3],[39.5, 28.0],[38.6, 29.2],[37.8, 27.9]],
        { color:"#b71c1c", fillColor:"#b71c1c", fillOpacity:0.18, weight:2 }
      ).bindTooltip("ğŸ”´ YÃ¼ksek Risk (Ã¶rnek)");

      flood.addTo(group);
      landslide.addTo(group);
      seismic.addTo(group);
      return group;
    }

    function buildLayerPack(map){
      return {
        topo: makeTopo(),
        osm: makeOSM(),
        water: makeWaterOverlay(map),
        settle: makeSettlementOverlay(map),
        risk: makeRiskOverlay(map)
      };
    }

    // Normal pack
    const layersNormal = buildLayerPack(mapNormal);

    function applyLayers(map, pack){
      // Remove all, then add in correct stacking order (so Ã¼st Ã¼ste dÃ¼zgÃ¼n)
      Object.values(pack).forEach(l => { try{ map.removeLayer(l); }catch(e){} });

      // Base-first: topo then osm (semi transparent), then overlays
      if(state.layers.topo) pack.topo.addTo(map);
      if(state.layers.osm) pack.osm.addTo(map);
      if(state.layers.water) pack.water.addTo(map);
      if(state.layers.settle) pack.settle.addTo(map);
      if(state.layers.risk) pack.risk.addTo(map);
    }

    applyLayers(mapNormal, layersNormal);

    /**************
     * UI: Layer toggles
     **************/
    function setButtonStates(scope){
      // scope: document or vrHud
      const root = scope || document;
      root.querySelectorAll(".layer-btn[data-layer]").forEach(btn=>{
        const key = btn.dataset.layer;
        const on = !!state.layers[key];
        btn.classList.toggle("off", !on);
        // highlight active selection for keyboard/gamepad navigation (VR)
        if(scope === $("vrHud")){
          const idx = state.layerOrder.indexOf(key);
          btn.style.outline = (idx === state.activeLayerIndex) ? "3px solid rgba(255,255,255,0.75)" : "none";
        }
      });
    }

    function toggleLayer(key){
      // topography can be toggled too, but usually keep it on. We'll allow toggling.
      state.layers[key] = !state.layers[key];
      addScore(5);

      applyLayers(mapNormal, layersNormal);
      if(mapLeft && mapRight){
        applyLayers(mapLeft, layersLeft);
        applyLayers(mapRight, layersRight);
      }
      setButtonStates(document);
      if($("vrHud")) setButtonStates($("vrHud"));
    }

    // Fix iOS tap reliability: pointerdown + touchstart
    function bindTap(el, handler){
      el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handler(e); }, { passive:false });
      el.addEventListener("touchstart", (e)=>{ e.preventDefault(); handler(e); }, { passive:false });
      el.addEventListener("click", (e)=>{ e.preventDefault(); handler(e); }, { passive:false });
    }

    // Bind normal layer bar
    document.querySelectorAll("#layerBar .layer-btn[data-layer]").forEach(btn=>{
      bindTap(btn, ()=> toggleLayer(btn.dataset.layer));
    });

    /**************
     * BEP MODE (simple)
     **************/
    function toggleBEP(){
      state.bep = !state.bep;
      document.body.style.fontSize = state.bep ? "18px" : "";
      $("bepBtn").textContent = state.bep ? "Normal Mod" : "BEP Modu";
      addScore(2);
    }
    bindTap($("bepBtn"), toggleBEP);

    /**************
     * Center + reset
     **************/
    bindTap($("centerTR"), ()=>{
      mapNormal.setView(trCenter, trZoom, { animate:true });
      addScore(2);
    });

    bindTap($("resetUI"), ()=>{
      state.layers = { topo:true, osm:true, water:false, settle:false, risk:false };
      state.activeLayerIndex = 0;
      applyLayers(mapNormal, layersNormal);
      if(mapLeft && mapRight){
        applyLayers(mapLeft, layersLeft);
        applyLayers(mapRight, layersRight);
      }
      setButtonStates(document);
      if($("vrHud")) setButtonStates($("vrHud"));
      addScore(1);
    });

    /**************
     * VR MODE (two synced maps)
     **************/
    let layersLeft = null;
    let layersRight = null;

    function isLandscape(){
      return window.matchMedia("(orientation: landscape)").matches;
    }

    function updateRotateHint(){
      const hint = $("rotateHint");
      if(state.vrOn && !isLandscape()) hint.classList.add("on");
      else hint.classList.remove("on");
    }

    function enterVR(){
      state.vrOn = true;
      $("vrOverlay").classList.add("on");
      document.body.classList.add("vr-lock");
      updateRotateHint();

      // Create VR maps once
      if(!mapLeft){
        mapLeft = L.map("mapLeft", { zoomControl:false, attributionControl:false, preferCanvas:true })
          .setView(mapNormal.getCenter(), mapNormal.getZoom());
        mapRight = L.map("mapRight", { zoomControl:false, attributionControl:false, preferCanvas:true })
          .setView(mapNormal.getCenter(), mapNormal.getZoom());

        layersLeft = buildLayerPack(mapLeft);
        layersRight = buildLayerPack(mapRight);

        applyLayers(mapLeft, layersLeft);
        applyLayers(mapRight, layersRight);

        // Keep both VR maps synced with each other
        const sync = (src, dst) => {
          src.on("move", ()=>{
            const c = src.getCenter(), z = src.getZoom();
            dst.setView(c, z, { animate:false });
          });
        };
        sync(mapLeft, mapRight);
        sync(mapRight, mapLeft);

        // Also sync from normal -> VR when enter
        const c = mapNormal.getCenter(), z = mapNormal.getZoom();
        mapLeft.setView(c, z, { animate:false });
        mapRight.setView(c, z, { animate:false });
      }else{
        // Already created -> just resize + sync
        setTimeout(()=>{
          mapLeft.invalidateSize();
          mapRight.invalidateSize();
          const c = mapNormal.getCenter(), z = mapNormal.getZoom();
          mapLeft.setView(c, z, { animate:false });
          mapRight.setView(c, z, { animate:false });
        }, 50);
      }

      // Bind VR HUD buttons (only once per open)
      $("vrHud").querySelectorAll(".layer-btn[data-layer]").forEach(btn=>{
        if(btn.dataset.bound) return;
        btn.dataset.bound = "1";
        bindTap(btn, ()=> toggleLayer(btn.dataset.layer));
      });

      bindTap($("vrCloseBtn"), exitVR);
      bindTap($("zoomIn"), ()=>{ mapLeft.zoomIn(); addScore(1); });
      bindTap($("zoomOut"), ()=>{ mapLeft.zoomOut(); addScore(1); });
      bindTap($("centerTR2"), ()=>{
        mapLeft.setView(trCenter, trZoom, { animate:true });
        addScore(2);
      });

      // Motion permission button
      bindTap($("motionBtn"), requestMotion);

      // Make sure buttons reflect state
      setButtonStates(document);
      setButtonStates($("vrHud"));

      addScore(10);
    }

    function exitVR(){
      state.vrOn = false;
      $("vrOverlay").classList.remove("on");
      document.body.classList.remove("vr-lock");
      updateRotateHint();

      // stop motion
      state.motionEnabled = false;
      $("motionBtn").textContent = "ğŸ› BaÅŸ Ä°zleme Ä°zni";
      addScore(5);
    }

    bindTap($("vrBtn"), enterVR);

    window.addEventListener("resize", ()=>{
      if(state.vrOn){
        updateRotateHint();
        if(mapLeft && mapRight){
          mapLeft.invalidateSize();
          mapRight.invalidateSize();
        }
      }
    }, { passive:true });

    window.addEventListener("orientationchange", ()=>{
      if(state.vrOn){
        setTimeout(()=>{
          updateRotateHint();
          if(mapLeft && mapRight){
            mapLeft.invalidateSize();
            mapRight.invalidateSize();
          }
        }, 250);
      }
    });

    /**************
     * Head tracking (DeviceOrientation) - best effort on iOS
     **************/
    async function requestMotion(){
      try{
        if(typeof DeviceOrientationEvent !== "undefined" &&
           typeof DeviceOrientationEvent.requestPermission === "function"){
          const res = await DeviceOrientationEvent.requestPermission();
          if(res !== "granted") throw new Error("Ä°zin verilmedi");
        }
        state.motionEnabled = true;
        $("motionBtn").textContent = "âœ… BaÅŸ Ä°zleme AÃ§Ä±k";
        addScore(5);
      }catch(e){
        alert("iOSâ€™ta baÅŸ izleme iÃ§in izin gerekebilir. Ayarlar > Safari > Hareket ve YÃ¶n eriÅŸimini kontrol edin.\n\nDetay: " + e.message);
      }
    }

    window.addEventListener("deviceorientation", (e)=>{
      if(!state.vrOn || !state.motionEnabled || !mapLeft) return;

      // e.alpha: yaw-like (0-360). We'll do a gentle pan.
      const now = performance.now();
      if(now - state.lastPanTs < 40) return; // throttle
      state.lastPanTs = now;

      const alpha = (e.alpha ?? 0);
      const beta = (e.beta ?? 0);

      // normalize
      // yaw: map pan east/west
      // pitch: map pan north/south
      const yaw = ((alpha + 540) % 360) - 180;  // -180..180
      const pitch = Math.max(-45, Math.min(45, beta)); // clamp

      // convert to small lat/lng delta depending on zoom
      const z = mapLeft.getZoom();
      const scale = 0.0008 * Math.pow(2, (7 - z)); // smaller when zoom in
      const dx = yaw * scale;
      const dy = pitch * scale;

      const c = mapLeft.getCenter();
      const next = L.latLng(c.lat + (-dy), c.lng + (dx));
      mapLeft.panTo(next, { animate:false });
    }, { passive:true });

    /**************
     * Keyboard / Bluetooth controller (acts as keyboard)
     **************/
    function vrLayerSelect(delta){
      state.activeLayerIndex = (state.activeLayerIndex + delta + state.layerOrder.length) % state.layerOrder.length;
      setButtonStates($("vrHud"));
    }

    document.addEventListener("keydown", (e)=>{
      // Works in normal too, but only meaningful in VR
      if(!state.vrOn) return;

      if(e.key === "ArrowLeft" || e.key === "ArrowUp"){
        e.preventDefault();
        vrLayerSelect(-1);
      }else if(e.key === "ArrowRight" || e.key === "ArrowDown"){
        e.preventDefault();
        vrLayerSelect(+1);
      }else if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        const key = state.layerOrder[state.activeLayerIndex];
        toggleLayer(key);
      }else if(e.key.toLowerCase() === "escape"){
        e.preventDefault();
        exitVR();
      }
    }, { passive:false });

    /**************
     * Gamepad API (best effort)
     **************/
    function pollGamepad(){
      if(!state.vrOn) return requestAnimationFrame(pollGamepad);
      const gps = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = gps && gps[0];
      if(gp){
        // D-pad / axis crude mapping
        const ax0 = gp.axes?.[0] ?? 0;
        const ax1 = gp.axes?.[1] ?? 0;

        // buttons typical: 12 up, 13 down, 14 left, 15 right
        const up = gp.buttons?.[12]?.pressed;
        const down = gp.buttons?.[13]?.pressed;
        const left = gp.buttons?.[14]?.pressed;
        const right = gp.buttons?.[15]?.pressed;
        const a = gp.buttons?.[0]?.pressed || gp.buttons?.[1]?.pressed; // A/B
        const back = gp.buttons?.[8]?.pressed;

        // simple edge detection by timestamps
        const t = performance.now();
        pollGamepad._last = pollGamepad._last || { t:0, up:false, down:false, left:false, right:false, a:false, back:false };
        if(t - pollGamepad._last.t > 160){
          if((left && !pollGamepad._last.left) || (up && !pollGamepad._last.up) || (ax0 < -0.7) || (ax1 < -0.7)){
            vrLayerSelect(-1); pollGamepad._last.t = t;
          }
          if((right && !pollGamepad._last.right) || (down && !pollGamepad._last.down) || (ax0 > 0.7) || (ax1 > 0.7)){
            vrLayerSelect(+1); pollGamepad._last.t = t;
          }
          if(a && !pollGamepad._last.a){
            const key = state.layerOrder[state.activeLayerIndex];
            toggleLayer(key);
            pollGamepad._last.t = t;
          }
          if(back && !pollGamepad._last.back){
            exitVR();
            pollGamepad._last.t = t;
          }
        }
        pollGamepad._last.up = !!up; pollGamepad._last.down = !!down;
        pollGamepad._last.left = !!left; pollGamepad._last.right = !!right;
        pollGamepad._last.a = !!a; pollGamepad._last.back = !!back;
      }
      requestAnimationFrame(pollGamepad);
    }
    requestAnimationFrame(pollGamepad);

    /**************
     * Init UI
     **************/
    setButtonStates(document);
    addScore(0);
  </script>
</body>
</html>
