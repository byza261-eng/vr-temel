<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HaritaG√∂z ‚Äî AR/VR Harita Okuryazarlƒ±ƒüƒ± Sim√ºlat√∂r√º</title>
  <style>
    :root{
      --bg1:#1a2a3a; --bg2:#2d4a5c;
      --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.10);
      --green:#4CAF50;
      --amber:#FFC107;
      --blue:#2196F3;
      --red:#D32F2F;
      --purple:#6A1B9A;
    }
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%}
    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%);
      color:#fff;
      overflow:auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: pan-y;
    }
    body.bep-mode{ font-size: 18px; }
    body.bep-mode .section-title{ font-size: 26px; }
    body.bep-mode button{ font-size: 18px; }

    .header{
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid rgba(76,175,80,.28);
      padding: 14px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .logo{
      font-size: 22px;
      font-weight: 900;
      color: var(--green);
      display:flex;
      gap:10px;
      align-items:center;
      white-space: nowrap;
    }
    .stats{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
      justify-content:flex-end;
    }
    .stat{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 8px 10px;
      text-align:center;
      min-width: 82px;
    }
    .stat .v{ font-size: 18px; font-weight: 900; color: var(--amber); line-height: 1.1; }
    .stat .l{ font-size: 11px; color:#B0BEC5; }

    .pill{
      border:0;
      border-radius: 16px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      color:#fff;
      background: rgba(255,255,255,.12);
    }
    .pill.bep{ background: var(--blue); }
    .pill.bep.active{ background: #FF9800; }
    .pill.vr{ background: var(--purple); }
    .pill.vr.active{ background: var(--red); }

    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px;
    }
    .section{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 14px;
      margin-bottom: 14px;
      backdrop-filter: blur(10px);
    }
    .section-title{
      font-size: 20px;
      font-weight: 900;
      color: var(--green);
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 10px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
    }

    .task{
      background: rgba(255,193,7,.16);
      border: 2px solid var(--amber);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .task .t1{ font-weight: 900; color: var(--amber); margin-bottom: 6px; }
    .task .t2{ color:#E0E0E0; line-height:1.4; }

    .sim{
      background: rgba(0,0,0,.28);
      border: 3px solid rgba(76,175,80,.7);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    .viewport{
      position: relative;
      width:100%;
      aspect-ratio: 16/9;
      min-height: 260px;
      border-radius: 14px;
      overflow:hidden;
      background: #10161c;
      border: 1px solid rgba(255,255,255,.08);
    }
    #terrainWrap{ position:absolute; inset:0; overflow:hidden; }
    canvas.terrain{ position:absolute; inset:0; width:100%; height:100%; }

    .layer{ position:absolute; inset:0; pointer-events:none; opacity:1; transition: opacity .18s; }
    .layer.hidden{ opacity:0; }

    .roads-layer{
      background:
        repeating-linear-gradient(90deg, transparent, transparent 70px, rgba(255,215,0,.55) 70px, rgba(255,215,0,.55) 73px),
        repeating-linear-gradient(0deg, transparent, transparent 110px, rgba(255,215,0,.45) 110px, rgba(255,215,0,.45) 113px);
      mix-blend-mode: screen;
      opacity: .85;
    }
    .water-layer{
      background:
        radial-gradient(circle at 30% 70%, rgba(30,144,255,.58) 0%, transparent 28%),
        radial-gradient(circle at 70% 40%, rgba(30,144,255,.50) 0%, transparent 24%),
        radial-gradient(circle at 55% 55%, rgba(30,144,255,.35) 0%, transparent 18%);
      mix-blend-mode: screen;
      opacity: .90;
    }
    .settlement-layer{
      background:
        radial-gradient(circle at 50% 30%, rgba(255,165,0,.42) 0%, transparent 20%),
        radial-gradient(circle at 20% 60%, rgba(255,165,0,.30) 0%, transparent 15%),
        radial-gradient(circle at 80% 70%, rgba(255,165,0,.30) 0%, transparent 15%);
      mix-blend-mode: screen;
      opacity: .85;
    }
    .risk-layer{
      background:
        radial-gradient(circle at 60% 80%, rgba(255,0,0,.52) 0%, transparent 24%),
        radial-gradient(circle at 25% 30%, rgba(255,0,0,.42) 0%, transparent 18%);
      mix-blend-mode: screen;
      opacity: .90;
    }

    .info{
      position:absolute;
      background: rgba(76,175,80,.92);
      color:#fff;
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      display:flex; gap:6px; align-items:center;
    }
    .pulse{ animation:pulse 1.8s infinite; }
    @keyframes pulse{ 0%,100%{transform:translateY(0)}50%{transform:translateY(-4px)} }

    .controls{ display:flex; flex-wrap:wrap; gap:8px; margin-top: 10px; }
    .btn{
      border:0;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      display:flex;
      align-items:center;
      gap:8px;
      transition: transform .12s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn.inactive{ opacity:.42; filter: grayscale(1); }
    .btn.topo{ background: linear-gradient(135deg,#8B4513,#D2691E); color:#fff; }
    .btn.roads{ background: linear-gradient(135deg,#FFD700,#FFA500); color:#1b1b1b; }
    .btn.water{ background: linear-gradient(135deg,#1E90FF,#4169E1); color:#fff; }
    .btn.settle{ background: linear-gradient(135deg,#FF6347,#FF8C00); color:#fff; }
    .btn.risk{ background: linear-gradient(135deg,#DC143C,#8B0000); color:#fff; }

    .dir{
      margin-top: 10px;
      display:grid;
      grid-template-columns: repeat(3, 54px);
      gap:8px;
      justify-content:center;
    }
    .dir button{
      width:54px; height:44px;
      border:0;
      border-radius: 12px;
      background: var(--blue);
      color:#fff;
      font-size: 18px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }

    .missions{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .mission{
      position:relative;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.12);
      background: linear-gradient(135deg, rgba(33,150,243,.18), rgba(76,175,80,.18));
      padding: 12px;
      overflow:hidden;
    }
    .mission.active{ border-color: rgba(255,193,7,.85); }
    .mission.completed{ border-color: rgba(76,175,80,.9); background: linear-gradient(135deg, rgba(76,175,80,.28), rgba(139,195,74,.22)); }
    .mBadge{
      position:absolute; top:10px; right:10px;
      width:28px; height:28px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.35);
      font-size: 14px;
    }
    .mTitle{ font-weight: 900; color: var(--green); margin-bottom: 6px; }
    .mDesc{ font-size: 12px; color:#CFD8DC; margin-bottom: 8px; line-height:1.35; }
    .mReward{ font-weight: 900; color: var(--amber); font-size: 12px; }

    .achievements{ display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    @media (max-width: 420px){ .achievements{ grid-template-columns: 1fr; } }
    .ach{
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      padding: 10px;
      text-align:center;
    }
    .ach.unlocked{ border-color: var(--amber); background: rgba(255,193,7,.10); }
    .achIcon{ font-size: 32px; margin-bottom: 6px; }
    .achName{ font-size: 12px; font-weight: 900; }
    .achDesc{ font-size: 10px; color:#B0BEC5; line-height:1.3; }

    .quizQ{
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      padding: 12px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,.08);
    }
    .quizQ .qText{ font-weight: 900; font-size: 13px; color:#E0E0E0; margin-bottom: 8px; line-height:1.35; }
    .opt{
      border: 2px solid transparent;
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,.10);
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .opt.selected{ border-color: var(--amber); background: rgba(255,193,7,.18); }
    .opt.correct{ border-color: var(--green); background: rgba(76,175,80,.18); }
    .opt.wrong{ border-color: #F44336; background: rgba(244,67,54,.18); }

    .primary{
      width:100%;
      border:0;
      border-radius: 16px;
      padding: 12px 14px;
      font-weight: 900;
      cursor:pointer;
      color:#fff;
      background: linear-gradient(135deg, var(--green), #8BC34A);
      user-select:none;
      touch-action: manipulation;
    }
    .primary:disabled{ opacity:.55; cursor:not-allowed; }

    .result{
      display:none;
      margin-top: 10px;
      border-radius: 16px;
      border: 2px solid rgba(76,175,80,.9);
      padding: 12px;
      text-align:center;
      background: linear-gradient(135deg, rgba(76,175,80,.18), rgba(33,150,243,.18));
    }
    .result .score{ font-size: 26px; font-weight: 900; color: var(--amber); }
    .result .msg{ margin-top: 6px; color:#E0E0E0; }

    /* VR */
    body.vr-on{ overflow:hidden; touch-action:none; }
    #vrOverlay{
      position:fixed; inset:0;
      background:#000;
      z-index: 9999;
      display:none;
    }
    body.vr-on #vrOverlay{ display:block; }

    #vrRoot{ position:absolute; inset:0; }
    #vrRoot.landscape .vrStage{ position:absolute; inset:0; transform:none; transform-origin:center center; }
    #vrRoot.portrait .vrStage{
      position:absolute;
      width: 100vh;
      height: 100vw;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%) rotate(90deg);
      transform-origin: center center;
    }

    .vrHud{
      position:absolute;
      left:0; right:0; top:0;
      z-index: 3;
      display:flex;
      gap:8px;
      padding: 10px;
      justify-content:center;
      align-items:center;
      background: linear-gradient(to bottom, rgba(0,0,0,.78), rgba(0,0,0,0));
      pointer-events:auto;
      flex-wrap:wrap;
    }
    .vrHud button{
      border:0;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      color:#fff;
      background: rgba(255,255,255,.12);
      touch-action: manipulation;
      user-select:none;
      backdrop-filter: blur(8px);
    }
    .vrHud .danger{ background: rgba(211,47,47,.92); }
    .vrHud .ok{ background: rgba(76,175,80,.85); }
    .vrHud .miniStat{
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--amber);
      min-width: 74px;
      text-align:center;
    }

    .eyes{ position:absolute; inset:0; display:flex; z-index: 2; }
    .eye{
      width:50%;
      height:100%;
      overflow:hidden;
      position:relative;
      border-left: 1px solid rgba(255,255,255,.06);
      border-right: 1px solid rgba(255,255,255,.06);
    }
    .vrView{
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      width: 100%;
      height: 100%;
    }
    canvas.vrTerrain{ position:absolute; inset:0; width:100%; height:100%; }
    .vrLayer{ position:absolute; inset:0; pointer-events:none; transition: opacity .18s; }
    .vrLayer.hidden{ opacity:0; }

    .vrHint{
      position:absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 900;
      font-size: 12px;
      color:#fff;
      pointer-events:none;
      white-space:nowrap;
    }

    @media (max-width: 420px){
      .vrHud button, .vrHud .miniStat{ padding: 9px 10px; font-size: 13px; }
    }
  </style>
</head>

<body>
  <div class="header">
    <div class="logo">üó∫Ô∏è HaritaG√∂z</div>
    <div class="stats">
      <div class="stat"><div class="v" id="score">0</div><div class="l">Puan</div></div>
      <div class="stat"><div class="v" id="level">1</div><div class="l">Seviye</div></div>
      <div class="stat"><div class="v" id="missions-completed">0/8</div><div class="l">G√∂rev</div></div>
      <button class="pill bep" id="bepBtn" type="button">BEP Modu</button>
      <button class="pill vr" id="vrBtn" type="button">VR Modu</button>
    </div>
  </div>

  <div class="container">
    <div class="section">
      <div class="section-title">üéØ AR Harita Sim√ºlat√∂r√º</div>

      <div class="grid">
        <div>
          <div class="task" id="taskBox">
            <div class="t1" id="taskTitle">Ho≈ü Geldiniz!</div>
            <div class="t2" id="taskDesc">
              Katmanlarƒ± a√ß/kapat. Y√∂n tu≈ülarƒ±yla bakƒ±≈ü a√ßƒ±sƒ±nƒ± deƒüi≈ütir. Bilgi noktalarƒ±na dokun.
              VR‚Äôde ‚ÄúBa≈ü ƒ∞zleme A√ß‚Äù ile kafanƒ± √ßevirdik√ße g√∂r√ºnt√º d√∂ner. üéÆ Kumanda da desteklenir.
            </div>
          </div>

          <div class="sim">
            <div class="viewport" id="viewport">
              <div id="terrainWrap">
                <canvas class="terrain" id="terrainCanvas"></canvas>
              </div>

              <div class="layer roads-layer hidden" id="layer-roads"></div>
              <div class="layer water-layer hidden" id="layer-water"></div>
              <div class="layer settlement-layer hidden" id="layer-settlement"></div>
              <div class="layer risk-layer hidden" id="layer-risk"></div>

              <div class="info pulse" style="top:26%; left:26%" data-info="topography">üìä Topografya</div>
              <div class="info pulse" style="top:70%; left:58%" data-info="risk">‚ö†Ô∏è Risk</div>
              <div class="info pulse" style="top:40%; left:70%" data-info="water">üíß Su</div>
            </div>

            <div class="controls">
              <button class="btn topo" data-layer="topography" type="button">üèîÔ∏è Topografya</button>
              <button class="btn roads inactive" data-layer="roads" type="button">üõ£Ô∏è Ula≈üƒ±m</button>
              <button class="btn water inactive" data-layer="water" type="button">üíß Su</button>
              <button class="btn settle inactive" data-layer="settlement" type="button">üèòÔ∏è Yerle≈üim</button>
              <button class="btn risk inactive" data-layer="risk" type="button">‚ö†Ô∏è Risk</button>
            </div>

            <div class="dir">
              <button class="direction" data-direction="nw" type="button">‚ÜñÔ∏è</button>
              <button class="direction" data-direction="n"  type="button">‚¨ÜÔ∏è</button>
              <button class="direction" data-direction="ne" type="button">‚ÜóÔ∏è</button>
              <button class="direction" data-direction="w"  type="button">‚¨ÖÔ∏è</button>
              <button class="direction" data-direction="e"  type="button">‚û°Ô∏è</button>
              <button class="direction" data-direction="sw" type="button">‚ÜôÔ∏è</button>
              <button class="direction" data-direction="s"  type="button">‚¨áÔ∏è</button>
              <button class="direction" data-direction="se" type="button">‚ÜòÔ∏è</button>
            </div>

            <div style="margin-top:10px;color:#B0BEC5;font-size:13px;line-height:1.45">
              Normal modda sayfa a≈üaƒüƒ± kayar ‚úÖ<br>
              VR modda iki g√∂z tam ekrana oturur ‚úÖ (telefon dikse otomatik d√∂ner)
            </div>
            <div id="padStatus" style="margin-top:8px;color:#B0BEC5;font-size:12px">
              üéÆ Kumanda: Baƒülƒ± deƒüil (Bluetooth ile baƒüla; bazƒ± kumandalar ‚Äúklavye‚Äù gibi davranƒ±r)
            </div>
          </div>
        </div>

        <div>
          <div class="section" style="margin-bottom:14px;">
            <div class="section-title">üéØ G√∂revler</div>
            <div class="missions" id="missions"></div>
          </div>

          <div class="section" style="margin-bottom:0;">
            <div class="section-title">üèÜ Ba≈üarƒ±mlar</div>
            <div class="achievements" id="achievements"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="section" id="quiz-section">
      <div class="section-title">üìù Harita Okuryazarlƒ±ƒüƒ± Testi</div>
      <div id="quiz"></div>
      <button class="primary" id="checkBtn" type="button">Cevaplarƒ± Kontrol Et</button>
      <div class="result" id="result">
        <div class="score" id="resultScore"></div>
        <div class="msg" id="resultMsg"></div>
      </div>
    </div>
  </div>

  <!-- VR OVERLAY -->
  <div id="vrOverlay" aria-hidden="true">
    <div id="vrRoot" class="landscape">
      <div class="vrStage">
        <div class="vrHud">
          <button id="vrClose" class="danger" type="button">‚úï Kapat</button>

          <button id="vrHeadBtn" class="ok" type="button">üß† Ba≈ü ƒ∞zleme A√ß</button>

          <button id="vrTopo" type="button">üèîÔ∏è</button>
          <button id="vrRoads" type="button">üõ£Ô∏è</button>
          <button id="vrWater" type="button">üíß</button>
          <button id="vrSettle" type="button">üèòÔ∏è</button>
          <button id="vrRisk" type="button">‚ö†Ô∏è</button>

          <button id="vrDirPrev" type="button">‚ü≤</button>
          <button id="vrDirNext" type="button">‚ü≥</button>

          <button id="vrBep" type="button">BEP</button>

          <div class="miniStat" id="vrMiniScore">0</div>
          <div class="miniStat" id="vrMiniLevel">Lv1</div>
        </div>

        <div class="eyes">
          <div class="eye">
            <div class="vrView">
              <canvas class="vrTerrain" id="vrCanvasL"></canvas>
              <div class="vrLayer roads-layer hidden" id="vr-roads-L"></div>
              <div class="vrLayer water-layer hidden" id="vr-water-L"></div>
              <div class="vrLayer settlement-layer hidden" id="vr-settlement-L"></div>
              <div class="vrLayer risk-layer hidden" id="vr-risk-L"></div>
              <div class="vrHint" id="vrHintL">üß≠ N</div>
            </div>
          </div>
          <div class="eye">
            <div class="vrView">
              <canvas class="vrTerrain" id="vrCanvasR"></canvas>
              <div class="vrLayer roads-layer hidden" id="vr-roads-R"></div>
              <div class="vrLayer water-layer hidden" id="vr-water-R"></div>
              <div class="vrLayer settlement-layer hidden" id="vr-settlement-R"></div>
              <div class="vrLayer risk-layer hidden" id="vr-risk-R"></div>
              <div class="vrHint" id="vrHintR">üß≠ N</div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    /* ===== iOS tƒ±klama saƒülamla≈ütƒ±rma ===== */
    function bindTap(el, fn){
      if(!el) return;
      const fire = (e)=>{ try{ e.preventDefault?.(); }catch(_){} fn(e); };
      el.addEventListener('touchend', fire, {passive:false});
      el.addEventListener('pointerup', fire, {passive:false});
      el.addEventListener('click', (e)=>{ e.preventDefault(); fn(e); }, false);
    }

    /* ===== Game State ===== */
    const gameState = {
      score: 0,
      level: 1,
      completedMissions: 0,
      activeLayers: new Set(['topography']),
      currentDirection: 'n',
      directionsExplored: new Set(['n']),
      layersUsed: new Set(['topography']),
      riskPointClicked: false,
      waterPointClicked: false,
      roadsExplored: false,
      quizCompleted: false,
      bepMode: false,
      vrOn: false,

      // Head tracking
      headTracking: false,
      headYawRad: 0,        // current yaw
      headYawZeroRad: null  // calibration baseline
    };

    const dirs = ['n','ne','e','se','s','sw','w','nw'];
    const dirLabel = {n:'N',ne:'NE',e:'E',se:'SE',s:'S',sw:'SW',w:'W',nw:'NW'};

    const missions = [
      { id:1, title:'Katmanlarƒ± Ke≈üfet', desc:'En az 3 katmanƒ± a√ß', reward:50, status:'active',
        check:()=> gameState.activeLayers.size >= 3
      },
      { id:2, title:'Y√∂n Bul', desc:'4 farklƒ± y√∂ne bak', reward:75, status:'locked',
        check:()=> gameState.directionsExplored.size >= 4
      },
      { id:3, title:'Risk Analizi', desc:'Risk katmanƒ± + risk noktasƒ±na dokun', reward:100, status:'locked',
        check:()=> gameState.activeLayers.has('risk') && gameState.riskPointClicked
      },
      { id:4, title:'Su Kaynaklarƒ±', desc:'Su katmanƒ± + su noktasƒ±na dokun', reward:100, status:'locked',
        check:()=> gameState.activeLayers.has('water') && gameState.waterPointClicked
      },
      { id:5, title:'G√ºzergah Planlama', desc:'Ula≈üƒ±m katmanƒ±nƒ± ke≈üfet', reward:150, status:'locked',
        check:()=> gameState.activeLayers.has('roads') && gameState.roadsExplored
      },
      { id:6, title:'Yerle≈üim Analizi', desc:'Yerle≈üim katmanƒ±nƒ± a√ß', reward:150, status:'locked',
        check:()=> gameState.activeLayers.has('settlement')
      },
      { id:7, title:'Harita Uzmanƒ±', desc:'Testi tamamla', reward:200, status:'locked',
        check:()=> gameState.quizCompleted
      },
      { id:8, title:'AR Ustasƒ±', desc:'1000 puana ula≈ü', reward:300, status:'locked',
        check:()=> gameState.completedMissions >= 7 && gameState.score >= 1000
      }
    ];

    const achievements = [
      { id:1, icon:'üó∫Ô∏è', name:'ƒ∞lk Ke≈üif', desc:'Bir katman kullandƒ±n', unlocked:false },
      { id:2, icon:'üß≠', name:'Y√∂n Bulma', desc:'4 y√∂ne baktƒ±n', unlocked:false },
      { id:3, icon:'‚ö†Ô∏è', name:'Risk', desc:'Risk noktasƒ±nƒ± ke≈üfettin', unlocked:false },
      { id:4, icon:'üíß', name:'Su', desc:'Su noktasƒ±nƒ± ke≈üfettin', unlocked:false },
      { id:5, icon:'üèÜ', name:'ƒ∞lk G√∂rev', desc:'Bir g√∂revi tamamladƒ±n', unlocked:false },
      { id:6, icon:'üìö', name:'500', desc:'500 puana ula≈ütƒ±n', unlocked:false },
      { id:7, icon:'üéì', name:'Test', desc:'Testi ge√ßtin', unlocked:false },
      { id:8, icon:'üëë', name:'Usta', desc:'Hepsi tamam', unlocked:false }
    ];

    const quizQuestions = [
      { q:'Haritada y√ºksekliƒüi g√∂steren katman hangisidir?', opts:['Topografya','Ula≈üƒ±m','Yerle≈üim','Risk B√∂lgeleri'], c:0 },
      { q:'Sel riski analizi i√ßin hangi katmanlar birlikte kullanƒ±lmalƒ±dƒ±r?', opts:['Sadece risk','Su + topografya','Sadece yerle≈üim','Sadece ula≈üƒ±m'], c:1 },
      { q:'Bir b√∂lgenin n√ºfus yoƒüunluƒüunu anlamak i√ßin hangi katman kullanƒ±lƒ±r?', opts:['Topografya','Su','Yerle≈üim','Ula≈üƒ±m'], c:2 },
      { q:'Yaya i√ßin g√ºvenli g√ºzergah planlarken hangi katmanlar √∂nemlidir?', opts:['Ula≈üƒ±m + risk','Sadece topografya','Sadece su','Sadece yerle≈üim'], c:0 },
      { q:'AR harita uygulamalarƒ±nƒ±n avantajƒ± nedir?', opts:['Daha pahalƒ±dƒ±r','Ger√ßek √ßevre ile harita birle≈üir','Sadece sƒ±nƒ±fta kullanƒ±lƒ±r','Tek katman g√∂sterir'], c:1 }
    ];
    const selected = {};

    /* ===== UI ===== */
    function updateStats(){
      document.getElementById('score').textContent = gameState.score;
      document.getElementById('level').textContent = gameState.level;
      document.getElementById('missions-completed').textContent = `${gameState.completedMissions}/${missions.length}`;

      document.getElementById('vrMiniScore').textContent = gameState.score;
      document.getElementById('vrMiniLevel').textContent = `Lv${gameState.level}`;

      const d = dirLabel[gameState.currentDirection];
      document.getElementById('vrHintL').textContent = `üß≠ ${d}`;
      document.getElementById('vrHintR').textContent = `üß≠ ${d}`;
    }

    function renderMissions(){
      const box = document.getElementById('missions');
      box.innerHTML = missions.map(m=>{
        const icon = (m.status==='locked')?'üîí':(m.status==='active')?'‚ö°':'‚úÖ';
        return `
          <div class="mission ${m.status}">
            <div class="mBadge">${icon}</div>
            <div class="mTitle">${m.title}</div>
            <div class="mDesc">${m.desc}</div>
            <div class="mReward">+${m.reward} puan</div>
          </div>
        `;
      }).join('');
    }

    function renderAchievements(){
      const box = document.getElementById('achievements');
      box.innerHTML = achievements.map(a=>`
        <div class="ach ${a.unlocked ? 'unlocked':''}">
          <div class="achIcon">${a.icon}</div>
          <div class="achName">${a.name}</div>
          <div class="achDesc">${a.desc}</div>
        </div>
      `).join('');
    }

    function renderQuiz(){
      const box = document.getElementById('quiz');
      box.innerHTML = quizQuestions.map((qq,i)=>{
        const opts = qq.opts.map((t,j)=>`
          <div class="opt" data-q="${i}" data-o="${j}">${t}</div>
        `).join('');
        return `<div class="quizQ"><div class="qText">${i+1}. ${qq.q}</div>${opts}</div>`;
      }).join('');
    }

    /* ===== Score/Achievement ===== */
    function addScore(points){
      gameState.score += points;
      if(gameState.score >= 500) unlockAchievement(6);

      const newLevel = Math.floor(gameState.score / 200) + 1;
      if(newLevel > gameState.level) gameState.level = newLevel;

      updateStats();
    }

    function unlockAchievement(id){
      const a = achievements.find(x=>x.id===id);
      if(!a || a.unlocked) return;
      a.unlocked = true;
      renderAchievements();
      addScore(50);
    }

    /* ===== Missions ===== */
    function completeMission(idx){
      const m = missions[idx];
      if(m.status==='completed') return;

      m.status = 'completed';
      gameState.completedMissions++;
      addScore(m.reward);

      if(gameState.completedMissions === 1) unlockAchievement(5);

      if(idx < missions.length-1 && missions[idx+1].status === 'locked'){
        missions[idx+1].status = 'active';
      }
    }

    function checkMissions(){
      missions.forEach((m, idx)=>{
        if(m.status === 'active' && m.check()) completeMission(idx);
        if(m.status === 'locked' && idx>0 && missions[idx-1].status === 'completed'){
          m.status = 'active';
        }
      });
      renderMissions();
      updateStats();
    }

    /* ===== Layers ===== */
    function setLayerVisibility(layerName, visible){
      const map = {
        roads: document.getElementById('layer-roads'),
        water: document.getElementById('layer-water'),
        settlement: document.getElementById('layer-settlement'),
        risk: document.getElementById('layer-risk')
      };
      const vmap = {
        roads: [document.getElementById('vr-roads-L'), document.getElementById('vr-roads-R')],
        water: [document.getElementById('vr-water-L'), document.getElementById('vr-water-R')],
        settlement: [document.getElementById('vr-settlement-L'), document.getElementById('vr-settlement-R')],
        risk: [document.getElementById('vr-risk-L'), document.getElementById('vr-risk-R')]
      };
      if(map[layerName]) map[layerName].classList.toggle('hidden', !visible);
      if(vmap[layerName]) vmap[layerName].forEach(el=> el.classList.toggle('hidden', !visible));
    }

    function updateLayerButtons(){
      document.querySelectorAll('.btn[data-layer]').forEach(btn=>{
        const name = btn.dataset.layer;
        if(name === 'topography'){ btn.classList.remove('inactive'); return; }
        const isOn = gameState.activeLayers.has(name);
        btn.classList.toggle('inactive', !isOn);
      });
    }

    function toggleLayer(layerName){
      if(layerName === 'topography'){
        gameState.activeLayers.add('topography');
        unlockAchievement(1);
        checkMissions();
        requestRender(true);
        return;
      }
      const isOn = gameState.activeLayers.has(layerName);
      if(isOn){
        gameState.activeLayers.delete(layerName);
        setLayerVisibility(layerName, false);
      }else{
        gameState.activeLayers.add(layerName);
        setLayerVisibility(layerName, true);
        gameState.layersUsed.add(layerName);
      }
      if(layerName === 'roads') gameState.roadsExplored = true;

      unlockAchievement(1);
      updateLayerButtons();
      checkMissions();
      requestRender(true);
    }

    /* ===== Directions ===== */
    function changeDirection(dir){
      gameState.currentDirection = dir;
      gameState.directionsExplored.add(dir);
      if(gameState.directionsExplored.size >= 4) unlockAchievement(2);
      checkMissions();
      requestRender(true);
    }
    function rotateDirection(step){
      const i = dirs.indexOf(gameState.currentDirection);
      const ni = (i + step + dirs.length) % dirs.length;
      changeDirection(dirs[ni]);
    }

    /* ===== Info Points ===== */
    function clickInfoPoint(type){
      if(type === 'risk'){ gameState.riskPointClicked = true; unlockAchievement(3); }
      if(type === 'water'){ gameState.waterPointClicked = true; unlockAchievement(4); }
      addScore(25);
      checkMissions();

      const vp = document.getElementById('viewport');
      vp.style.filter = 'brightness(1.15)';
      setTimeout(()=>vp.style.filter='brightness(1)', 150);
    }

    /* ===== Quiz ===== */
    function selectQuizOption(q,o,el){
      document.querySelectorAll(`.opt[data-q="${q}"]`).forEach(x=>x.classList.remove('selected'));
      el.classList.add('selected');
      selected[q] = o;
    }
    function checkQuiz(){
      let correct = 0;
      quizQuestions.forEach((qq,i)=>{
        const chosen = selected[i];
        const opts = document.querySelectorAll(`.opt[data-q="${i}"]`);
        opts.forEach(el=>{
          const oi = parseInt(el.dataset.o,10);
          el.classList.remove('correct','wrong');
          if(oi === qq.c) el.classList.add('correct');
          if(chosen === oi && chosen !== qq.c) el.classList.add('wrong');
        });
        if(chosen === qq.c) correct++;
      });

      const pct = (correct / quizQuestions.length) * 100;
      const res = document.getElementById('result');
      res.style.display = 'block';
      document.getElementById('resultScore').textContent = `${correct}/${quizQuestions.length}`;

      let msg = '';
      if(pct >= 80){
        msg = 'M√ºkemmel! Harita okuryazarlƒ±ƒüƒ±nda ustasƒ±n! üèÜ';
        addScore(200);
        unlockAchievement(7);
      }else if(pct >= 60){
        msg = 'ƒ∞yi! Geli≈ümeye devam et! üëç';
        addScore(150);
      }else{
        msg = 'Daha fazla pratik yapmalƒ±sƒ±n! üí™';
        addScore(100);
      }
      document.getElementById('resultMsg').textContent = msg;
      document.getElementById('checkBtn').disabled = true;
      gameState.quizCompleted = true;
      checkMissions();
    }

    /* ===== BEP ===== */
    function toggleBEP(){
      gameState.bepMode = !gameState.bepMode;
      document.body.classList.toggle('bep-mode', gameState.bepMode);

      const btn = document.getElementById('bepBtn');
      btn.classList.toggle('active', gameState.bepMode);
      btn.textContent = gameState.bepMode ? 'Normal Mod' : 'BEP Modu';
      document.getElementById('vrBep').textContent = gameState.bepMode ? 'Normal' : 'BEP';
    }

    /* ===== VR ===== */
    function setVRRootClass(){
      const isPortrait = window.innerHeight > window.innerWidth;
      const vrRoot = document.getElementById('vrRoot');
      vrRoot.className = isPortrait ? 'portrait' : 'landscape';
    }

    function openVR(){
      if(gameState.vrOn) return;
      gameState.vrOn = true;

      document.body.classList.add('vr-on');
      document.getElementById('vrOverlay').setAttribute('aria-hidden','false');

      const vrBtn = document.getElementById('vrBtn');
      vrBtn.classList.add('active');
      vrBtn.textContent = 'VR Kapat';

      setVRRootClass();
      resizeAllCanvases();
      requestRender(true);
      updateHeadBtn();
    }

    function closeVR(){
      if(!gameState.vrOn) return;
      gameState.vrOn = false;

      // ba≈ü izleme a√ßƒ±kken kapat
      stopHeadTracking();

      document.body.classList.remove('vr-on');
      document.getElementById('vrOverlay').setAttribute('aria-hidden','true');

      const vrBtn = document.getElementById('vrBtn');
      vrBtn.classList.remove('active');
      vrBtn.textContent = 'VR Modu';
      updateHeadBtn();
    }

    function toggleVR(){
      if(gameState.vrOn) closeVR();
      else openVR();
    }

    /* ===== Head Tracking (DeviceOrientation) =====
       - iOS requires user gesture permission
       - We use yaw (alpha/compass) as camera yaw offset
    */
    function updateHeadBtn(){
      const b = document.getElementById('vrHeadBtn');
      if(!b) return;
      if(!gameState.vrOn){
        b.textContent = 'üß† Ba≈ü ƒ∞zleme A√ß';
        b.classList.add('ok');
        return;
      }
      b.textContent = gameState.headTracking ? 'üß† Ba≈ü ƒ∞zleme Kapat' : 'üß† Ba≈ü ƒ∞zleme A√ß';
      b.classList.toggle('ok', !gameState.headTracking);
    }

    function normalizeRad(a){
      while(a > Math.PI) a -= Math.PI*2;
      while(a < -Math.PI) a += Math.PI*2;
      return a;
    }

    function onDeviceOrientation(e){
      // iOS Safari sometimes provides webkitCompassHeading (0..360, 0=N)
      // Else use alpha (0..360, 0 at device reference)
      let headingDeg = null;

      if(typeof e.webkitCompassHeading === 'number'){
        headingDeg = e.webkitCompassHeading;
      } else if(typeof e.alpha === 'number'){
        // alpha: 0..360 (clockwise)
        headingDeg = e.alpha;
      }

      if(headingDeg === null) return;

      const yaw = (headingDeg * Math.PI/180);
      if(gameState.headYawZeroRad === null){
        // calibrate baseline on first reading
        gameState.headYawZeroRad = yaw;
      }
      const rel = normalizeRad(yaw - gameState.headYawZeroRad);
      gameState.headYawRad = rel;

      if(gameState.vrOn) requestRender(false);
    }

    async function startHeadTracking(){
      if(gameState.headTracking) return;
      // iOS permission
      const DO = window.DeviceOrientationEvent;
      if(!DO){
        alert('Bu cihazda DeviceOrientation desteklenmiyor.');
        return;
      }

      if(typeof DO.requestPermission === 'function'){
        try{
          const res = await DO.requestPermission();
          if(res !== 'granted'){
            alert('Ba≈ü izleme izni verilmedi.');
            return;
          }
        }catch(err){
          alert('Ba≈ü izleme izni alƒ±namadƒ±.');
          return;
        }
      }

      gameState.headYawZeroRad = null;
      gameState.headYawRad = 0;
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      gameState.headTracking = true;
      updateHeadBtn();
      requestRender(true);
    }

    function stopHeadTracking(){
      if(!gameState.headTracking) return;
      window.removeEventListener('deviceorientation', onDeviceOrientation, true);
      gameState.headTracking = false;
      gameState.headYawZeroRad = null;
      gameState.headYawRad = 0;
      updateHeadBtn();
      requestRender(true);
    }

    function toggleHeadTracking(){
      if(!gameState.vrOn) return;
      if(gameState.headTracking) stopHeadTracking();
      else startHeadTracking();
    }

    /* ===== 3D-ish Terrain Renderer ===== */
    const terrain = {
      size: 64,
      heights: null,
      seed: 1337,
      needsRender: true,
      raf: 0
    };

    function rand2d(x,y){
      const s = Math.sin(x*127.1 + y*311.7 + terrain.seed) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothstep(t){ return t*t*(3-2*t); }
    function noise(x,y){
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const xf = x - x0, yf = y - y0;
      const r00 = rand2d(x0,y0), r10 = rand2d(x0+1,y0);
      const r01 = rand2d(x0,y0+1), r11 = rand2d(x0+1,y0+1);
      const u = smoothstep(xf), v = smoothstep(yf);
      const a = r00*(1-u) + r10*u;
      const b = r01*(1-u) + r11*u;
      return a*(1-v) + b*v;
    }
    function fbm(x,y){
      let n=0, amp=0.55, f=1.0;
      for(let i=0;i<5;i++){
        n += amp*noise(x*f, y*f);
        f *= 2.0;
        amp *= 0.55;
      }
      return n;
    }
    function generateHeightmap(){
      const N = terrain.size;
      const h = new Float32Array(N*N);
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const nx = x/(N-1), ny = y/(N-1);
          const dx = nx-0.5, dy=ny-0.5;
          const d = Math.sqrt(dx*dx+dy*dy);
          const fall = Math.max(0, 1 - d*1.7);

          let e = fbm(nx*3.0, ny*3.0);
          e = e*1.15 - 0.1;
          e *= fall;

          const river = Math.abs((nx*1.2 + ny*0.8) - 0.9);
          e -= Math.max(0, 0.20 - river)*1.3;

          h[y*N + x] = Math.max(-0.2, Math.min(1.0, e));
        }
      }
      terrain.heights = h;
    }

    function getYawForDirection(dir){
      const map = { n:0, ne:45, e:90, se:135, s:180, sw:225, w:270, nw:315 };
      return (map[dir] ?? 0) * Math.PI/180;
    }

    function projectPoint(x,y,z, cam){
      const cx = x - cam.center;
      const cy = y - cam.center;

      const cosY = Math.cos(cam.yaw), sinY = Math.sin(cam.yaw);
      const rx = cx*cosY - cy*sinY;
      const ry = cx*sinY + cy*cosY;

      const cosP = Math.cos(cam.pitch), sinP = Math.sin(cam.pitch);
      const rz = z;
      const ty = ry*cosP - rz*sinP;
      const tz = ry*sinP + rz*cosP;

      const px = rx;
      const py = ty;
      const pz = tz + cam.dist;

      const sx = cam.w/2 + (px * cam.fov) / pz;
      const sy = cam.h/2 + (py * cam.fov) / pz;
      return [sx, sy, pz];
    }

    function shadeColor(z, dzdx, dzdy){
      const lx=0.6, ly=0.4, lz=0.7;
      let nx = -dzdx, ny = -dzdy, nz = 1.0;
      const inv = 1 / Math.sqrt(nx*nx+ny*ny+nz*nz);
      nx*=inv; ny*=inv; nz*=inv;
      const diff = Math.max(0.0, nx*lx + ny*ly + nz*lz);
      let r,g,b;
      if(z < 0.05){ r=35; g=95; b=140; }
      else if(z < 0.22){ r=46; g=145; b=85; }
      else if(z < 0.45){ r=76; g=170; b=90; }
      else if(z < 0.70){ r=130; g=110; b=70; }
      else { r=170; g=160; b=140; }
      const amb = 0.35;
      const lit = amb + diff*0.75;
      r = Math.min(255, Math.floor(r*lit));
      g = Math.min(255, Math.floor(g*lit));
      b = Math.min(255, Math.floor(b*lit));
      return `rgb(${r},${g},${b})`;
    }

    function drawTerrain(ctx, w, h, eyeOffset=0){
      const N = terrain.size;
      const H = terrain.heights;

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0,0,w,h);

      // Base yaw from direction + optional head tracking offset (VR only)
      const baseYaw = getYawForDirection(gameState.currentDirection);
      const headYaw = (gameState.vrOn && gameState.headTracking) ? gameState.headYawRad : 0;
      const yaw = baseYaw + headYaw;

      const cam = {
        w,h,
        yaw: yaw + eyeOffset,
        pitch: 0.85,
        dist: 2.2,
        fov: Math.min(w,h)*1.10,
        center: (N-1)/2
      };

      const order = [];
      for(let y=0;y<N-1;y++){
        for(let x=0;x<N-1;x++){
          order.push([x,y]);
        }
      }
      const cosY = Math.cos(cam.yaw), sinY = Math.sin(cam.yaw);
      order.sort((a,b)=>{
        const ax=a[0]-cam.center, ay=a[1]-cam.center;
        const bx=b[0]-cam.center, by=b[1]-cam.center;
        const ary = ax*sinY + ay*cosY;
        const bry = bx*sinY + by*cosY;
        return ary - bry;
      });

      const scaleZ = 2.2;

      for(const [x,y] of order){
        const i00 = y*N + x;
        const i10 = y*N + (x+1);
        const i01 = (y+1)*N + x;
        const i11 = (y+1)*N + (x+1);

        const z00 = H[i00]*scaleZ;
        const z10 = H[i10]*scaleZ;
        const z01 = H[i01]*scaleZ;
        const z11 = H[i11]*scaleZ;

        const p00 = projectPoint(x,y,z00,cam);
        const p10 = projectPoint(x+1,y,z10,cam);
        const p01 = projectPoint(x,y+1,z01,cam);
        const p11 = projectPoint(x+1,y+1,z11,cam);

        const dzdx = (z10 - z00 + z11 - z01) * 0.5;
        const dzdy = (z01 - z00 + z11 - z10) * 0.5;

        ctx.beginPath();
        ctx.moveTo(p00[0],p00[1]);
        ctx.lineTo(p10[0],p10[1]);
        ctx.lineTo(p11[0],p11[1]);
        ctx.closePath();
        ctx.fillStyle = shadeColor((z00+z10+z11)/3/scaleZ, dzdx, dzdy);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(p00[0],p00[1]);
        ctx.lineTo(p11[0],p11[1]);
        ctx.lineTo(p01[0],p01[1]);
        ctx.closePath();
        ctx.fillStyle = shadeColor((z00+z11+z01)/3/scaleZ, dzdx, dzdy);
        ctx.fill();
      }

      const grd = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.15, w/2,h/2, Math.min(w,h)*0.75);
      grd.addColorStop(0,'rgba(0,0,0,0)');
      grd.addColorStop(1,'rgba(0,0,0,0.45)');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,w,h);
    }

    function resizeCanvasToDisplaySize(canvas){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
        return true;
      }
      return false;
    }

    function resizeAllCanvases(){
      const c = document.getElementById('terrainCanvas');
      resizeCanvasToDisplaySize(c);

      const vL = document.getElementById('vrCanvasL');
      const vR = document.getElementById('vrCanvasR');
      resizeCanvasToDisplaySize(vL);
      resizeCanvasToDisplaySize(vR);
    }

    function requestRender(force=false){
      terrain.needsRender = true;
      if(force) terrain.needsRender = true;
      if(!terrain.raf){
        terrain.raf = requestAnimationFrame(renderFrame);
      }
    }

    function renderFrame(){
      terrain.raf = 0;
      resizeAllCanvases();
      if(!terrain.needsRender) return;
      terrain.needsRender = false;

      const c = document.getElementById('terrainCanvas');
      drawTerrain(c.getContext('2d'), c.width, c.height, 0);

      if(gameState.vrOn){
        const vL = document.getElementById('vrCanvasL');
        const vR = document.getElementById('vrCanvasR');
        drawTerrain(vL.getContext('2d'), vL.width, vL.height, -0.025);
        drawTerrain(vR.getContext('2d'), vR.width, vR.height, +0.025);
      }
    }

    function syncLayersToUI(){
      setLayerVisibility('roads', gameState.activeLayers.has('roads'));
      setLayerVisibility('water', gameState.activeLayers.has('water'));
      setLayerVisibility('settlement', gameState.activeLayers.has('settlement'));
      setLayerVisibility('risk', gameState.activeLayers.has('risk'));
      updateLayerButtons();
      updateStats();
      requestRender(true);
    }

    /* ===== Kumanda (Gamepad + Keyboard fallback) ===== */
    function setPadStatus(text){
      const el = document.getElementById('padStatus');
      if(el) el.textContent = text;
    }
    const pad = { index:null, lastButtons:[], lastAxes:[0,0,0,0], lastActionAt:0 };
    function nowMs(){ return performance.now(); }
    function throttle(ms=180){
      const t = nowMs();
      if(t - pad.lastActionAt < ms) return false;
      pad.lastActionAt = t;
      return true;
    }
    function nextLayerToggle(){
      const order = ['roads','water','settlement','risk'];
      const firstOff = order.find(l => !gameState.activeLayers.has(l));
      toggleLayer(firstOff || order[0]);
    }
    function prevLayerToggle(){
      const order = ['risk','settlement','water','roads'];
      const firstOff = order.find(l => !gameState.activeLayers.has(l));
      toggleLayer(firstOff || order[0]);
    }
    function handlePadButtonPress(btnIndex){
      if(!throttle()) return;
      switch(btnIndex){
        case 15: rotateDirection(+1); break;
        case 14: rotateDirection(-1); break;
        case 12: prevLayerToggle(); break;
        case 13: nextLayerToggle(); break;
        case 0:  nextLayerToggle(); break;      // A
        case 2:  prevLayerToggle(); break;      // X
        case 9:  toggleVR(); break;             // Start
        case 8:  toggleBEP(); break;            // Select/Back
        case 1:  toggleLayer('risk'); break;    // B
        case 3:  toggleLayer('water'); break;   // Y
      }
    }
    function pollGamepads(){
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      if(!pads){ requestAnimationFrame(pollGamepads); return; }

      if(pad.index === null){
        for(let i=0;i<pads.length;i++){
          if(pads[i]){
            pad.index = i;
            setPadStatus(`üéÆ Kumanda: Baƒülandƒ± ‚Äî ${pads[i].id}`);
            break;
          }
        }
      }

      const gp = (pad.index !== null) ? pads[pad.index] : null;
      if(gp){
        const buttons = gp.buttons || [];
        for(let i=0;i<buttons.length;i++){
          const pressed = !!buttons[i]?.pressed;
          const wasPressed = !!pad.lastButtons[i];
          if(pressed && !wasPressed) handlePadButtonPress(i);
          pad.lastButtons[i] = pressed;
        }

        const ax = gp.axes?.[0] ?? 0;
        if(Math.abs(ax) > 0.7){
          if(Math.abs(pad.lastAxes[0]) <= 0.7){
            if(throttle()){
              if(ax > 0) rotateDirection(+1);
              else rotateDirection(-1);
            }
          }
        }
        pad.lastAxes[0] = ax;
      } else {
        if(pad.index !== null){
          pad.index = null;
          pad.lastButtons = [];
          setPadStatus('üéÆ Kumanda: Baƒülƒ± deƒüil (Bluetooth ile yeniden baƒüla)');
        }
      }
      requestAnimationFrame(pollGamepads);
    }
    window.addEventListener('gamepadconnected', (e)=>{
      pad.index = e.gamepad.index;
      pad.lastButtons = [];
      setPadStatus(`üéÆ Kumanda: Baƒülandƒ± ‚Äî ${e.gamepad.id}`);
    });
    window.addEventListener('gamepaddisconnected', ()=>{
      pad.index = null;
      pad.lastButtons = [];
      setPadStatus('üéÆ Kumanda: Baƒülƒ± deƒüil (Bluetooth ile yeniden baƒüla)');
    });

    // Keyboard fallback
    window.addEventListener('keydown', (e)=>{
      const k = e.key;
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Enter',' ','Escape'].includes(k)) e.preventDefault();
      if(!throttle()) return;
      if(k === 'ArrowLeft') rotateDirection(-1);
      if(k === 'ArrowRight') rotateDirection(+1);
      if(k === 'ArrowUp') prevLayerToggle();
      if(k === 'ArrowDown') nextLayerToggle();
      if(k === 'Enter' || k === ' ') nextLayerToggle();
      if(k === 'Escape') { if(gameState.vrOn) closeVR(); }
    });

    /* ===== Events ===== */
    function wire(){
      document.querySelectorAll('.btn[data-layer]').forEach(btn=>{
        bindTap(btn, ()=> toggleLayer(btn.dataset.layer));
      });
      document.querySelectorAll('.direction').forEach(btn=>{
        bindTap(btn, ()=> changeDirection(btn.dataset.direction));
      });
      document.querySelectorAll('.info').forEach(p=>{
        bindTap(p, ()=> clickInfoPoint(p.dataset.info));
      });

      const quizBox = document.getElementById('quiz');
      quizBox.addEventListener('touchend', (e)=>{
        const el = e.target.closest('.opt');
        if(!el) return;
        e.preventDefault();
        selectQuizOption(parseInt(el.dataset.q,10), parseInt(el.dataset.o,10), el);
      }, {passive:false});
      quizBox.addEventListener('pointerup', (e)=>{
        const el = e.target.closest('.opt');
        if(!el) return;
        e.preventDefault();
        selectQuizOption(parseInt(el.dataset.q,10), parseInt(el.dataset.o,10), el);
      }, {passive:false});
      quizBox.addEventListener('click', (e)=>{
        const el = e.target.closest('.opt');
        if(!el) return;
        e.preventDefault();
        selectQuizOption(parseInt(el.dataset.q,10), parseInt(el.dataset.o,10), el);
      });

      bindTap(document.getElementById('checkBtn'), checkQuiz);
      bindTap(document.getElementById('bepBtn'), toggleBEP);
      bindTap(document.getElementById('vrBtn'), toggleVR);
      bindTap(document.getElementById('vrClose'), closeVR);

      bindTap(document.getElementById('vrTopo'), ()=> toggleLayer('topography'));
      bindTap(document.getElementById('vrRoads'), ()=> toggleLayer('roads'));
      bindTap(document.getElementById('vrWater'), ()=> toggleLayer('water'));
      bindTap(document.getElementById('vrSettle'), ()=> toggleLayer('settlement'));
      bindTap(document.getElementById('vrRisk'), ()=> toggleLayer('risk'));
      bindTap(document.getElementById('vrDirPrev'), ()=> rotateDirection(-1));
      bindTap(document.getElementById('vrDirNext'), ()=> rotateDirection(+1));
      bindTap(document.getElementById('vrBep'), toggleBEP);

      // Head tracking toggle
      bindTap(document.getElementById('vrHeadBtn'), toggleHeadTracking);

      document.getElementById('vrOverlay').addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

      window.addEventListener('resize', ()=>{
        if(gameState.vrOn) setVRRootClass();
        resizeAllCanvases();
        requestRender(true);
      });
      window.addEventListener('orientationchange', ()=>{
        setTimeout(()=>{
          if(gameState.vrOn) setVRRootClass();
          resizeAllCanvases();
          requestRender(true);
        }, 250);
      });
    }

    function init(){
      generateHeightmap();
      renderMissions();
      renderAchievements();
      renderQuiz();
      updateStats();
      syncLayersToUI();
      wire();

      checkMissions();

      requestAnimationFrame(()=>{
        resizeAllCanvases();
        requestRender(true);
      });

      // gamepad polling start
      requestAnimationFrame(pollGamepads);
    }

    init();
  </script>
</body>
</html>
