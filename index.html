<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>HaritaG√∂z - VR/AR Harita Okuryazarlƒ±ƒüƒ± Sim√ºlat√∂r√º</title>
  <style>
    :root{
      --bg1:#1a2a3a;
      --bg2:#2d4a5c;
      --panel:rgba(255,255,255,0.06);
      --panel2:rgba(0,0,0,0.35);
      --green:#4CAF50;
      --yellow:#FFC107;
      --blue:#2196F3;
      --text:#ffffff;

      --hudH:64px;
      --hudPad:10px;
      --radius:18px;

      /* VR lens ayarlarƒ± */
      --lensVignetteInner: 55%;
      --lensVignetteMid: 72%;
      --lensVignetteOuter: 100%;

      /* 3D hissi (parallax) */
      --depth-topo: 0.15;
      --depth-water: 0.35;
      --depth-roads: 0.55;
      --depth-settle: 0.75;
      --depth-risk: 0.85;
      --depth-ui: 1.0;
    }

    *{ box-sizing:border-box; margin:0; padding:0; }
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Helvetica Neue", sans-serif;
      background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
      color: var(--text);
      overflow-x:hidden;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }

    /* Header / stats (Normal mod) */
    .header{
      background: rgba(0,0,0,0.30);
      padding: 16px 14px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      backdrop-filter: blur(10px);
      border-bottom: 2px solid rgba(76,175,80,0.28);
      position: sticky;
      top: 0;
      z-index: 50;
    }
    .logo{
      font-size: 22px;
      font-weight: 800;
      color: var(--green);
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      white-space:nowrap;
    }
    .stats{
      display:flex;
      align-items:center;
      gap:14px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .stat-item{ text-align:center; min-width:64px; }
    .stat-value{ font-size:18px; font-weight:800; color: var(--yellow); line-height:1.1; }
    .stat-label{ font-size:11px; color:#B0BEC5; }

    .btn{
      border:none;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight:800;
      cursor:pointer;
      transition: transform .15s ease, filter .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .btn:active{ transform: scale(0.98); }
    .btn-blue{ background: var(--blue); color:white; }
    .btn-green{ background: linear-gradient(135deg, var(--green), #8BC34A); color:white; }
    .btn-orange{ background: #FF9800; color:white; }
    .btn-dark{ background: rgba(255,255,255,0.10); color:white; border:1px solid rgba(255,255,255,0.15); }
    .btn:hover{ filter:brightness(1.06); }

    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 14px 30px;
    }

    .section{
      background: var(--panel);
      border-radius: var(--radius);
      padding: 18px;
      margin-bottom: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .section-title{
      font-size: 22px;
      margin-bottom: 12px;
      color: var(--green);
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 900;
    }

    /* ===== MAP / SIM ===== */
    .sim-shell{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .task-prompt{
      background: rgba(255,193,7,0.14);
      border: 2px solid rgba(255,193,7,0.65);
      padding: 12px 14px;
      border-radius: 14px;
    }
    .task-prompt-title{ font-size:16px; font-weight:900; color: var(--yellow); margin-bottom:6px; }
    .task-prompt-desc{ font-size:14px; color:#E0E0E0; }

    /* Viewport panel */
    .viewport-panel{
      background: rgba(0,0,0,0.35);
      border: 2px solid rgba(76,175,80,0.55);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
      position:relative;
    }

    /* Normal viewport (single) */
    #normalViewport{
      width: 100%;
      height: min(62vh, 520px);
      border-radius: 14px;
      overflow:hidden;
      position:relative;
      background: #0b1218;
    }

    /* "World" scene (we transform this for pan/zoom/rotation) */
    .world{
      position:absolute;
      inset: 0;
      transform-origin: 50% 50%;
      will-change: transform;
    }

    /* Base topography background */
    .layer{
      position:absolute;
      inset:0;
      pointer-events:none; /* layers are visual only */
      opacity: 1;
      transition: opacity .18s ease;
      will-change: transform, opacity;
    }
    .hiddenLayer{ opacity:0; }

    /* Topography (always on) */
    .topo{
      background:
        radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.06) 0%, transparent 45%),
        radial-gradient(ellipse at 70% 40%, rgba(255,255,255,0.04) 0%, transparent 42%),
        radial-gradient(ellipse at 55% 70%, rgba(0,0,0,0.30) 0%, transparent 50%),
        linear-gradient(to bottom, #6fbf73 0%, #88c57a 35%, #bca06c 60%, #8b6a3d 100%);
      filter: contrast(1.08) saturate(1.05);
    }
    /* Relief lines */
    .topo::after{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(  8deg, rgba(0,0,0,0.00) 0 10px, rgba(0,0,0,0.06) 10px 11px ),
        repeating-linear-gradient( -12deg, rgba(255,255,255,0.00) 0 14px, rgba(255,255,255,0.04) 14px 15px );
      mix-blend-mode: overlay;
      opacity: .55;
    }

    /* Turkey silhouette mask (keeps it "Turkey-like") */
    .mask{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .mask svg{ width:100%; height:100%; display:block; }
    .mask .sea{ fill: rgba(11,18,24,0.92); }
    .mask .landCut{
      fill: rgba(0,0,0,0);
      stroke: rgba(255,255,255,0.14);
      stroke-width: 2.5;
    }

    /* Overlays (water/roads/settlement/risk) */
    .water{ }
    .water svg .waterFill{ fill: rgba(30,144,255,0.40); stroke: rgba(30,144,255,0.75); stroke-width:2; }
    .water svg .river{ fill:none; stroke: rgba(30,144,255,0.80); stroke-width:2.2; stroke-linecap:round; opacity:.9; }
    .water svg .lake{ fill: rgba(30,144,255,0.45); stroke: rgba(30,144,255,0.85); stroke-width:1.8; opacity:.95; }

    .roads svg .road{ fill:none; stroke: rgba(255,215,0,0.85); stroke-width:2.6; stroke-linecap:round; }
    .roads svg .road2{ fill:none; stroke: rgba(255,165,0,0.75); stroke-width:2.0; stroke-linecap:round; opacity:0.85; }
    .roads svg .node{ fill: rgba(255,215,0,0.95); opacity:0.9; }

    .settlement svg .city{ fill: rgba(255,99,71,0.90); stroke: rgba(255,255,255,0.25); stroke-width:1.2; }
    .settlement svg text{
      fill: rgba(255,255,255,0.92);
      font-size: 11px;
      font-weight:800;
      paint-order: stroke;
      stroke: rgba(0,0,0,0.45);
      stroke-width: 3px;
    }

    .risk svg .zone{ fill: rgba(220,20,60,0.32); stroke: rgba(220,20,60,0.70); stroke-width:2; }
    .risk svg .icon{ fill: rgba(255,255,255,0.90); opacity:0.95; }

    /* Controls in normal mode */
    .controlsRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
    }
    .layer-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .layer-btn{
      border:none;
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight:900;
      font-size: 13px;
      display:flex;
      align-items:center;
      gap:8px;
      transition: transform .15s ease, filter .15s ease, opacity .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .layer-btn:active{ transform: scale(0.98); }

    .layer-btn.topography{ background: linear-gradient(135deg,#8B4513,#D2691E); color:white; }
    .layer-btn.roads{ background: linear-gradient(135deg,#FFD700,#FFA500); color:#2b2b2b; }
    .layer-btn.water{ background: linear-gradient(135deg,#1E90FF,#4169E1); color:white; }
    .layer-btn.settlement{ background: linear-gradient(135deg,#FF6347,#FF8C00); color:white; }
    .layer-btn.risk{ background: linear-gradient(135deg,#DC143C,#8B0000); color:white; }

    .inactive{ opacity:0.42; filter: grayscale(100%); }

    .nav-controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .miniBtn{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:white;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .miniBtn:active{ transform: scale(0.98); }

    /* Missions / achievements / quiz (keep simple but present) */
    .grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 900px){
      .grid2{ grid-template-columns: 1.2fr 0.8fr; }
    }

    .missions{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 10px;
    }
    .mission-card{
      background: linear-gradient(135deg, rgba(33,150,243,0.18), rgba(76,175,80,0.18));
      padding: 14px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,0.16);
      position:relative;
      transition: transform .15s ease, border-color .15s ease;
    }
    .mission-card.active{ border-color: rgba(255,193,7,0.8); }
    .mission-card.completed{ border-color: rgba(76,175,80,0.85); }
    .mission-title{ font-weight:900; color: var(--green); margin-bottom:6px; }
    .mission-desc{ color:#CFD8DC; font-size: 13px; margin-bottom: 8px; }
    .mission-reward{ color: var(--yellow); font-weight:900; }

    .achievements{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .achievement{
      background: rgba(255,255,255,0.05);
      padding: 12px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,0.10);
      text-align:center;
      transition: transform .15s ease;
    }
    .achievement.unlocked{ border-color: rgba(255,193,7,0.85); background: rgba(255,193,7,0.10); }
    .achievement-icon{ font-size: 36px; margin-bottom: 6px; filter: grayscale(100%); }
    .achievement.unlocked .achievement-icon{ filter: grayscale(0%); }
    .achievement-name{ font-weight:900; font-size: 13px; }
    .achievement-desc{ font-size: 11px; color:#B0BEC5; margin-top:4px; }

    .quiz-question{
      background: rgba(255,255,255,0.05);
      padding: 14px;
      border-radius: 14px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .quiz-question-text{ font-weight:900; margin-bottom:10px; color:#E0E0E0; }
    .quiz-options{ display:flex; flex-direction:column; gap:8px; }
    .quiz-option{
      padding: 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.08);
      border: 2px solid transparent;
      cursor:pointer;
      transition: border-color .15s ease, background .15s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .quiz-option.selected{ border-color: rgba(255,193,7,0.85); background: rgba(255,193,7,0.18); }
    .quiz-option.correct{ border-color: rgba(76,175,80,0.85); background: rgba(76,175,80,0.18); }
    .quiz-option.wrong{ border-color: rgba(244,67,54,0.85); background: rgba(244,67,54,0.18); }

    .result-panel{
      background: linear-gradient(135deg, rgba(76,175,80,0.18), rgba(33,150,243,0.18));
      padding: 16px;
      border-radius: 14px;
      border: 2px solid rgba(76,175,80,0.55);
      text-align:center;
      margin-top: 10px;
    }
    .hidden{ display:none; }

    /* BEP Mode */
    body.bep-mode{ font-size: 18px; }
    body.bep-mode .section-title{ font-size: 28px; }
    body.bep-mode .layer-btn, body.bep-mode .miniBtn, body.bep-mode .btn{ font-size: 16px; padding: 14px 16px; }
    body.bep-mode .quiz-option{ font-size: 16px; padding: 16px; }

    /* ===== VR MODE ===== */
    body.vr-active{
      overflow:hidden;
      height:100vh;
    }

    #vrOverlay{
      position:fixed;
      inset:0;
      background: #000;
      z-index: 9999;
      display:none;
    }
    body.vr-active #vrOverlay{ display:block; }

    /* VR HUD */
    .vrHud{
      position:absolute;
      top: 0;
      left:0;
      right:0;
      height: var(--hudH);
      padding: var(--hudPad);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      background: rgba(0,0,0,0.50);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,0.15);
      z-index: 10000;
      pointer-events:auto;
    }

    .vrHudLeft, .vrHudRight{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .hudPill{
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: white;
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select:none;
    }
    .hudPill:active{ transform: scale(0.98); }
    .hudPill.inactive{ opacity:0.48; filter: grayscale(1); }

    /* VR eyes container (landscape, two eyes) */
    .vrStage{
      position:absolute;
      top: var(--hudH);
      left:0; right:0; bottom:0;
      display:flex;
      gap: 0;
      background:#000;
    }
    .eye{
      position:relative;
      width:50%;
      height:100%;
      overflow:hidden;
      background:#000;
    }

    /* Lens vignette + round feel */
    .eye::after{
      content:"";
      position:absolute;
      inset:-7%;
      pointer-events:none;
      background: radial-gradient(circle at center,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,0) var(--lensVignetteInner),
        rgba(0,0,0,0.55) var(--lensVignetteMid),
        rgba(0,0,0,0.96) var(--lensVignetteOuter)
      );
      z-index: 12000;
    }

    /* Each eye shows the same scene, with tiny stereo offset */
    .eye .eyeScene{
      position:absolute;
      inset:0;
      transform-origin: 50% 50%;
      will-change: transform;
    }

    /* Reticle for "look & click" (works with Enter/Space) */
    .reticle{
      position:absolute;
      left:50%;
      top:50%;
      width: 14px;
      height: 14px;
      transform: translate(-50%,-50%);
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.85);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.55);
      z-index: 12010;
      pointer-events:none;
      opacity:0.92;
    }
    .reticle::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width: 3px;
      height: 3px;
      transform: translate(-50%,-50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.95);
    }

    /* Bottom VR nav */
    .vrBottom{
      position:absolute;
      left:0; right:0;
      bottom: 10px;
      display:flex;
      justify-content:center;
      z-index: 12020;
      pointer-events:auto;
    }
    .vrBottom .pad{
      display:flex;
      gap: 8px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.16);
      padding: 10px;
      border-radius: 16px;
      backdrop-filter: blur(10px);
    }

    /* Make normal controls more compact on small screens */
    @media (max-width: 768px){
      .stats{ gap:10px; }
      #normalViewport{ height: min(60vh, 520px); }
      .layer-btn{ font-size: 12px; padding: 10px 10px; }
    }

    /* Force landscape hint overlay (optional, we keep it gentle) */
    #rotateHint{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.82);
      z-index: 20000;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
    }
    #rotateHint .card{
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.18);
      padding: 18px;
      border-radius: 18px;
      max-width: 520px;
    }
    #rotateHint h2{ color: var(--yellow); margin-bottom: 8px; }
    #rotateHint p{ color: #E0E0E0; line-height: 1.4; }
  </style>
</head>

<body>
  <div class="header">
    <div class="logo">üó∫Ô∏è HaritaG√∂z</div>
    <div class="stats">
      <div class="stat-item">
        <div class="stat-value" id="score">0</div>
        <div class="stat-label">Puan</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="level">1</div>
        <div class="stat-label">Seviye</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="missions-completed">0/8</div>
        <div class="stat-label">G√∂rev</div>
      </div>

      <button class="btn btn-dark" id="vrBtn">ü•Ω VR Modu</button>
      <button class="btn btn-blue" id="bepBtn">BEP Modu</button>
    </div>
  </div>

  <div class="container">
    <div class="section">
      <div class="section-title">üéØ Harita Sim√ºlat√∂r√º</div>

      <div class="task-prompt" id="currentTask">
        <div class="task-prompt-title">Ho≈ü geldiniz!</div>
        <div class="task-prompt-desc">
          Topografya hep a√ßƒ±k. Diƒüer katmanlarƒ± butonlardan a√ß/kapa yapƒ±n. VR modda ba≈üƒ±nƒ±zƒ± √ßevirip haritayƒ± gezin,
          ileri/geri ile yakla≈üƒ±n. (Kumanda/klavye: 1..5 katman, ‚Üë‚Üì ileri/geri, ‚Üê‚Üí d√∂n, +/- zoom, V VR)
        </div>
      </div>

      <div class="viewport-panel">
        <div id="normalViewport">
          <div class="world" id="world">
            <!-- Topography (always on) -->
            <div class="layer topo" id="L_topo"></div>

            <!-- Turkey silhouette mask (sea around) -->
            <div class="mask layer" id="L_mask">
              <!-- Simple Turkey-ish silhouette (stylized) -->
              <svg viewBox="0 0 1000 600" preserveAspectRatio="none" aria-hidden="true">
                <!-- Sea -->
                <rect class="sea" x="0" y="0" width="1000" height="600"></rect>

                <!-- Land cutout: we "fake" mask by drawing land border and relying on our topo under it.
                     We'll instead overlay sea and draw a large "land" path with transparent fill:
                     For simplicity: draw land border and let topo show through by setting sea rect opacity.
                -->
                <path class="landCut" d="M105,305
                  C120,275 160,250 210,245
                  C250,240 270,220 300,205
                  C345,180 395,170 440,175
                  C480,180 510,165 545,155
                  C585,140 630,145 665,160
                  C705,178 740,175 770,165
                  C815,147 855,160 885,190
                  C915,220 905,260 870,280
                  C845,295 840,315 860,335
                  C885,360 880,395 845,410
                  C815,428 770,430 725,420
                  C680,410 650,430 610,450
                  C565,472 520,475 485,465
                  C450,452 420,470 390,485
                  C340,510 285,500 250,480
                  C220,462 185,470 160,455
                  C120,430 90,380 105,305 Z" />
              </svg>
            </div>

            <!-- WATER -->
            <div class="layer water hiddenLayer" id="L_water">
              <svg viewBox="0 0 1000 600" preserveAspectRatio="none">
                <!-- Seas (stylized) -->
                <path class="waterFill" d="M70,245 C140,145 250,110 380,115 C480,120 540,105 600,85 C650,70 720,70 815,90
                  C880,108 930,150 955,210 L955,0 L0,0 L0,300 C20,280 40,265 70,245 Z"/>
                <path class="waterFill" d="M0,520 C90,560 170,560 240,535 C310,512 380,515 440,530
                  C510,555 590,555 660,530 C740,500 835,490 1000,520 L1000,600 L0,600 Z"/>
                <!-- Rivers -->
                <path class="river" d="M340,245 C360,280 370,320 360,360 C350,405 360,450 390,495" />
                <path class="river" d="M540,210 C565,240 585,275 590,315 C595,350 585,395 560,430" />
                <path class="river" d="M720,210 C745,245 760,285 755,330 C750,380 720,420 690,450" />
                <!-- Lakes -->
                <ellipse class="lake" cx="600" cy="375" rx="34" ry="18"/>
                <ellipse class="lake" cx="455" cy="395" rx="22" ry="12"/>
              </svg>
            </div>

            <!-- ROADS -->
            <div class="layer roads hiddenLayer" id="L_roads">
              <svg viewBox="0 0 1000 600" preserveAspectRatio="none">
                <path class="road" d="M160,390 C240,340 310,310 390,285 C470,260 560,240 645,220 C725,200 810,195 880,205" />
                <path class="road" d="M230,455 C300,410 365,385 445,365 C520,346 600,330 680,310 C760,292 820,285 860,290" />
                <path class="road2" d="M290,240 C320,270 350,310 360,360 C368,402 385,440 410,480" />
                <path class="road2" d="M560,190 C560,250 555,300 545,350 C535,395 515,435 485,468" />
                <path class="road2" d="M720,210 C710,255 700,300 690,340 C680,385 650,420 610,450" />
                <!-- Nodes -->
                <circle class="node" cx="230" cy="455" r="4"/>
                <circle class="node" cx="360" cy="360" r="4"/>
                <circle class="node" cx="545" cy="350" r="4"/>
                <circle class="node" cx="690" cy="340" r="4"/>
                <circle class="node" cx="860" cy="290" r="4"/>
              </svg>
            </div>

            <!-- SETTLEMENT -->
            <div class="layer settlement hiddenLayer" id="L_settlement">
              <svg viewBox="0 0 1000 600" preserveAspectRatio="none">
                <!-- Major cities (approx positions for demo) -->
                <circle class="city" cx="210" cy="370" r="6"/><text x="222" y="374">ƒ∞stanbul</text>
                <circle class="city" cx="265" cy="430" r="5"/><text x="277" y="434">ƒ∞zmir</text>
                <circle class="city" cx="460" cy="380" r="5"/><text x="472" y="384">Ankara</text>
                <circle class="city" cx="585" cy="420" r="5"/><text x="597" y="424">Kayseri</text>
                <circle class="city" cx="715" cy="420" r="5"/><text x="727" y="424">Diyarbakƒ±r</text>
                <circle class="city" cx="815" cy="370" r="5"/><text x="827" y="374">Trabzon</text>
                <circle class="city" cx="520" cy="505" r="5"/><text x="532" y="509">Antalya</text>
              </svg>
            </div>

            <!-- RISK -->
            <div class="layer risk hiddenLayer" id="L_risk">
              <svg viewBox="0 0 1000 600" preserveAspectRatio="none">
                <!-- Sample risk zones (stylized) -->
                <path class="zone" d="M520,470 C560,440 600,435 640,450 C675,465 690,490 680,520 C670,550 635,565 595,560 C560,555 525,535 510,510 C495,485 500,485 520,470 Z"/>
                <path class="zone" d="M250,320 C280,295 320,290 350,305 C375,318 385,345 370,370 C355,396 320,410 290,400 C260,390 235,360 240,340 C245,330 245,328 250,320 Z"/>
                <!-- Icons -->
                <text class="icon" x="585" y="510" font-size="24">‚ö†Ô∏è</text>
                <text class="icon" x="305" y="360" font-size="24">‚ö†Ô∏è</text>
              </svg>
            </div>

          </div>
        </div>

        <div class="controlsRow">
          <div class="layer-controls">
            <button class="layer-btn topography" data-layer="topo">üèîÔ∏è Topografya</button>
            <button class="layer-btn roads inactive" data-layer="roads">üõ£Ô∏è Ula≈üƒ±m</button>
            <button class="layer-btn water inactive" data-layer="water">üíß Su</button>
            <button class="layer-btn settlement inactive" data-layer="settlement">üèòÔ∏è Yerle≈üim</button>
            <button class="layer-btn risk inactive" data-layer="risk">‚ö†Ô∏è Risk</button>
          </div>

          <div class="nav-controls">
            <button class="miniBtn" id="zoomIn">‚ûï</button>
            <button class="miniBtn" id="zoomOut">‚ûñ</button>
            <button class="miniBtn" id="resetView">üîÑ Sƒ±fƒ±rla</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Missions & Achievements -->
    <div class="section">
      <div class="section-title">üéØ G√∂revler & üèÜ Ba≈üarƒ±mlar</div>
      <div class="grid2">
        <div>
          <div class="missions" id="missions"></div>
        </div>
        <div>
          <div class="achievements" id="achievements"></div>
        </div>
      </div>
    </div>

    <!-- Quiz -->
    <div class="section" id="quizSection">
      <div class="section-title">üìù Harita Okuryazarlƒ±ƒüƒ± Testi</div>
      <div id="quiz"></div>
      <button class="btn btn-green" id="checkAnswers" style="margin-top:8px;">Cevaplarƒ± Kontrol Et</button>
      <div class="result-panel hidden" id="quizResult">
        <div style="font-size:42px;font-weight:900;color:var(--yellow);" id="quizScore"></div>
        <div style="font-size:18px;font-weight:900;color:#E0E0E0;" id="quizMsg"></div>
      </div>
    </div>
  </div>

  <!-- VR Overlay -->
  <div id="vrOverlay" aria-hidden="true">
    <div class="vrHud">
      <div class="vrHudLeft">
        <button class="hudPill" id="vrExit">‚üµ √áƒ±k</button>
        <span class="hudPill" id="vrStatus" style="cursor:default;">VR: Hazƒ±r</span>
      </div>

      <div class="vrHudRight">
        <button class="hudPill" data-vrlayer="roads" id="vrBtnRoads">üõ£Ô∏è</button>
        <button class="hudPill" data-vrlayer="water" id="vrBtnWater">üíß</button>
        <button class="hudPill" data-vrlayer="settlement" id="vrBtnSettlement">üèòÔ∏è</button>
        <button class="hudPill" data-vrlayer="risk" id="vrBtnRisk">‚ö†Ô∏è</button>
        <button class="hudPill" id="vrZoomIn">‚ûï</button>
        <button class="hudPill" id="vrZoomOut">‚ûñ</button>
      </div>
    </div>

    <div class="vrStage">
      <div class="eye" id="eyeL">
        <div class="eyeScene" id="eyeSceneL"></div>
        <div class="reticle"></div>
      </div>
      <div class="eye" id="eyeR">
        <div class="eyeScene" id="eyeSceneR"></div>
        <div class="reticle"></div>
      </div>

      <div class="vrBottom">
        <div class="pad">
          <button class="hudPill" id="moveFwd">‚¨ÜÔ∏è ƒ∞leri</button>
          <button class="hudPill" id="moveBack">‚¨áÔ∏è Geri</button>
          <button class="hudPill" id="turnLeft">‚¨ÖÔ∏è</button>
          <button class="hudPill" id="turnRight">‚û°Ô∏è</button>
          <button class="hudPill" id="vrReset">üîÑ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rotate hint -->
  <div id="rotateHint">
    <div class="card">
      <h2>Telefonu yana √ßevir</h2>
      <p>VR modda en iyi deneyim i√ßin telefonu <b>yatay</b> konumda kullan. (Yine de √ßalƒ±≈üƒ±r; sadece g√∂r√ºnt√º daha iyi oturur.)</p>
      <div style="height:10px;"></div>
      <button class="btn btn-green" id="hideRotateHint">Tamam</button>
    </div>
  </div>

  <script>
    /***********************
     * GAME STATE + DATA
     ***********************/
    const gameState = {
      score: 0,
      level: 1,
      completedMissions: 0,
      activeLayers: {
        topo: true, roads: false, water: false, settlement: false, risk: false
      },
      directionsExplored: 0,
      layersUsed: new Set(["topo"]),
      riskPointClicked: false,
      waterPointClicked: false,
      roadsExplored: false,
      quizCompleted: false,
      bepMode: false,
      vrActive: false
    };

    const missions = [
      { id:1, title:"Katmanlarƒ± Ke≈üfet", desc:"En az 3 katmanƒ± a√ß/kapa yap", reward:50, status:"active", check:()=> gameState.layersUsed.size >= 3 },
      { id:2, title:"Y√∂n Bul", desc:"Saƒü/sol d√∂nme ile 4 kez y√∂n deƒüi≈ütir", reward:75, status:"locked", check:()=> gameState.directionsExplored >= 4 },
      { id:3, title:"Risk Analizi", desc:"Risk katmanƒ±nƒ± a√ß", reward:100, status:"locked", check:()=> gameState.activeLayers.risk === true },
      { id:4, title:"Su Kaynaklarƒ±", desc:"Su katmanƒ±nƒ± a√ß", reward:100, status:"locked", check:()=> gameState.activeLayers.water === true },
      { id:5, title:"G√ºzergah Planlama", desc:"Ula≈üƒ±m katmanƒ±nƒ± a√ß", reward:150, status:"locked", check:()=> gameState.activeLayers.roads === true },
      { id:6, title:"Yerle≈üim Analizi", desc:"Yerle≈üim katmanƒ±nƒ± a√ß", reward:150, status:"locked", check:()=> gameState.activeLayers.settlement === true },
      { id:7, title:"Harita Uzmanƒ±", desc:"Testi tamamla", reward:200, status:"locked", check:()=> gameState.quizCompleted === true },
      { id:8, title:"AR Ustasƒ±", desc:"7 g√∂revi tamamla ve 1000 puana yakla≈ü", reward:300, status:"locked", check:()=> gameState.completedMissions >= 7 && gameState.score >= 800 }
    ];

    const achievements = [
      { id:1, icon:"üó∫Ô∏è", name:"ƒ∞lk Ke≈üif", desc:"ƒ∞lk katmanƒ± kullandƒ±n", unlocked:false },
      { id:2, icon:"üß≠", name:"Y√∂n Bulma", desc:"4 y√∂n hareketi yaptƒ±n", unlocked:false },
      { id:3, icon:"‚ö†Ô∏è", name:"Risk Farkƒ±ndalƒ±ƒüƒ±", desc:"Risk katmanƒ±nƒ± a√ßtƒ±n", unlocked:false },
      { id:4, icon:"üíß", name:"Su Ka≈üifi", desc:"Su katmanƒ±nƒ± a√ßtƒ±n", unlocked:false },
      { id:5, icon:"üèÜ", name:"ƒ∞lk G√∂rev", desc:"ƒ∞lk g√∂revi tamamladƒ±n", unlocked:false },
      { id:6, icon:"üìö", name:"Bilgi Avcƒ±sƒ±", desc:"500 puana ula≈ütƒ±n", unlocked:false },
      { id:7, icon:"üéì", name:"Harita Uzmanƒ±", desc:"Testi ge√ßtin", unlocked:false },
      { id:8, icon:"üëë", name:"AR Ustasƒ±", desc:"T√ºm g√∂revlerde ilerledin", unlocked:false }
    ];

    const quizQuestions = [
      { question:"Haritada y√ºkseltiyi g√∂steren temel katman hangisidir?", options:["Topografya","Ula≈üƒ±m","Yerle≈üim","Risk"], correct:0 },
      { question:"Sel riski analizi i√ßin hangi katmanlar birlikte yorumlanmalƒ±dƒ±r?", options:["Sadece risk","Su + topografya","Sadece yerle≈üim","Sadece ula≈üƒ±m"], correct:1 },
      { question:"N√ºfus yoƒüunluƒüu okumada en uygun katman hangisidir?", options:["Topografya","Su","Yerle≈üim","Ula≈üƒ±m"], correct:2 },
      { question:"Yaya i√ßin g√ºvenli g√ºzerg√¢h planlarken hangileri √∂nemlidir?", options:["Ula≈üƒ±m + risk","Sadece topografya","Sadece su","Sadece yerle≈üim"], correct:0 },
      { question:"VR/AR harita uygulamalarƒ±nƒ±n temel avantajƒ± nedir?", options:["Tek katman g√∂sterir","Ger√ßek baƒülamda √ßoklu katman","Sadece sƒ±nƒ±fta kullanƒ±lƒ±r","Daha pahalƒ±dƒ±r"], correct:1 }
    ];

    /***********************
     * CAMERA / VIEW (pan/zoom/rotate)
     ***********************/
    const camera = {
      x: 0,   // pan x
      y: 0,   // pan y
      zoom: 1.0,
      yaw: 0,   // degrees
      pitch: 0  // degrees
    };

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function applyTransformsToWorld(targetEl, stereoOffsetPx=0){
      // Base transform: pan/zoom/rotate
      const z = camera.zoom;
      const rot = camera.yaw;
      const panX = camera.x + stereoOffsetPx;
      const panY = camera.y;

      // world transform (rotate then scale then translate)
      targetEl.style.transform =
        `translate(${panX}px, ${panY}px) rotate(${rot}deg) scale(${z})`;
    }

    // Parallax per-layer (3D hissi)
    function applyParallax(worldRoot){
      // yaw/pitch -> tiny px shift
      const yaw = camera.yaw;
      const pitch = camera.pitch;

      // Convert degrees to shift (tune)
      const sx = clamp(yaw, -35, 35) * 0.8;
      const sy = clamp(pitch, -25, 25) * 0.8;

      const topo = worldRoot.querySelector("#L_topo");
      const water = worldRoot.querySelector("#L_water");
      const roads = worldRoot.querySelector("#L_roads");
      const settle = worldRoot.querySelector("#L_settlement");
      const risk = worldRoot.querySelector("#L_risk");
      const mask = worldRoot.querySelector("#L_mask");

      // Depth factors
      const dTopo = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-topo"));
      const dWater = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-water"));
      const dRoads = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-roads"));
      const dSet  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-settle"));
      const dRisk = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-risk"));

      // Apply subtle offsets
      topo.style.transform = `translate(${sx*dTopo}px, ${sy*dTopo}px)`;
      mask.style.transform = `translate(${sx*dTopo}px, ${sy*dTopo}px)`;

      water.style.transform = `translate(${sx*dWater}px, ${sy*dWater}px)`;
      roads.style.transform = `translate(${sx*dRoads}px, ${sy*dRoads}px)`;
      settle.style.transform = `translate(${sx*dSet}px, ${sy*dSet}px)`;
      risk.style.transform = `translate(${sx*dRisk}px, ${sy*dRisk}px)`;
    }

    function updateView(){
      const world = document.getElementById("world");
      applyTransformsToWorld(world, 0);
      applyParallax(world);

      if (gameState.vrActive){
        updateVREyes();
      }
    }

    /***********************
     * NORMAL MODE LAYERS
     ***********************/
    const layerMap = {
      topo: document.getElementById("L_topo"),
      water: document.getElementById("L_water"),
      roads: document.getElementById("L_roads"),
      settlement: document.getElementById("L_settlement"),
      risk: document.getElementById("L_risk")
    };

    function setLayerVisible(layerKey, visible){
      if (layerKey === "topo" || layerKey === "topography") return; // topo always on

      const id = "L_" + layerKey;
      const el = document.getElementById(id);
      const btn = document.querySelector(`.layer-btn[data-layer="${layerKey}"]`);
      const vbtn = document.querySelector(`.hudPill[data-vrlayer="${layerKey}"]`);

      if (!el) return;

      if (visible){
        el.classList.remove("hiddenLayer");
        btn?.classList.remove("inactive");
        vbtn?.classList.remove("inactive");
        gameState.activeLayers[layerKey] = true;
        gameState.layersUsed.add(layerKey);
      } else {
        el.classList.add("hiddenLayer");
        btn?.classList.add("inactive");
        vbtn?.classList.add("inactive");
        gameState.activeLayers[layerKey] = false;
      }

      // achievements quick hooks
      if (!achievements[0].unlocked) unlockAchievement(1);
      if (layerKey === "roads" && visible){ gameState.roadsExplored = true; }
      if (layerKey === "water" && visible){ if(!achievements[3].unlocked) unlockAchievement(4); }
      if (layerKey === "risk" && visible){ if(!achievements[2].unlocked) unlockAchievement(3); }

      checkMissions();
      updateView();
    }

    function toggleLayer(layerKey){
      if (layerKey === "topo" || layerKey === "topography"){
        // topo always on; we still pulse feedback
        flashStatus("Topografya her zaman a√ßƒ±k ‚úÖ");
        if (!achievements[0].unlocked) unlockAchievement(1);
        return;
      }
      const current = gameState.activeLayers[layerKey];
      setLayerVisible(layerKey, !current);
    }

    /***********************
     * VR MODE: clone scene into two eyes
     ***********************/
    let vrWorldL = null;
    let vrWorldR = null;

    function buildVREyes(){
      // Clone the normal viewport "world" into each eye scene
      const world = document.getElementById("world");

      const eyeSceneL = document.getElementById("eyeSceneL");
      const eyeSceneR = document.getElementById("eyeSceneR");
      eyeSceneL.innerHTML = "";
      eyeSceneR.innerHTML = "";

      // Create wrappers so we can transform independently
      const cloneL = world.cloneNode(true);
      const cloneR = world.cloneNode(true);
      cloneL.id = "worldVRL";
      cloneR.id = "worldVRR";

      // Ensure pointer events off inside VR eyes (HUD handles clicks)
      cloneL.style.pointerEvents = "none";
      cloneR.style.pointerEvents = "none";

      eyeSceneL.appendChild(cloneL);
      eyeSceneR.appendChild(cloneR);

      vrWorldL = cloneL;
      vrWorldR = cloneR;

      // Sync layers with current state
      syncAllLayersToVR();
      updateVREyes();
    }

    function syncAllLayersToVR(){
      // apply visibility from gameState into VR clones
      const keys = ["water","roads","settlement","risk"];
      keys.forEach(k=>{
        const visible = gameState.activeLayers[k];
        const elL = vrWorldL?.querySelector("#L_"+k);
        const elR = vrWorldR?.querySelector("#L_"+k);
        if (elL && elR){
          elL.classList.toggle("hiddenLayer", !visible);
          elR.classList.toggle("hiddenLayer", !visible);
        }
      });
    }

    function applyParallaxVR(worldRoot){
      const yaw = camera.yaw;
      const pitch = camera.pitch;
      const sx = clamp(yaw, -35, 35) * 0.8;
      const sy = clamp(pitch, -25, 25) * 0.8;

      const topo = worldRoot.querySelector("#L_topo");
      const water = worldRoot.querySelector("#L_water");
      const roads = worldRoot.querySelector("#L_roads");
      const settle = worldRoot.querySelector("#L_settlement");
      const risk = worldRoot.querySelector("#L_risk");
      const mask = worldRoot.querySelector("#L_mask");

      const dTopo = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-topo"));
      const dWater = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-water"));
      const dRoads = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-roads"));
      const dSet  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-settle"));
      const dRisk = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--depth-risk"));

      topo.style.transform = `translate(${sx*dTopo}px, ${sy*dTopo}px)`;
      mask.style.transform = `translate(${sx*dTopo}px, ${sy*dTopo}px)`;
      water.style.transform = `translate(${sx*dWater}px, ${sy*dWater}px)`;
      roads.style.transform = `translate(${sx*dRoads}px, ${sy*dRoads}px)`;
      settle.style.transform = `translate(${sx*dSet}px, ${sy*dSet}px)`;
      risk.style.transform = `translate(${sx*dRisk}px, ${sy*dRisk}px)`;
    }

    function updateVREyes(){
      if (!vrWorldL || !vrWorldR) return;

      // Stereo offsets in px (small)
      const stereo = 10;

      // Apply world transform (same camera but slightly shifted)
      applyTransformsToWorld(vrWorldL, -stereo);
      applyTransformsToWorld(vrWorldR, +stereo);

      // Parallax inside each eye
      applyParallaxVR(vrWorldL);
      applyParallaxVR(vrWorldR);
    }

    function enterVR(){
      if (gameState.vrActive) return;
      gameState.vrActive = true;

      document.body.classList.add("vr-active");
      document.getElementById("vrOverlay").setAttribute("aria-hidden", "false");

      // Show rotate hint if portrait
      maybeRotateHint();

      buildVREyes();
      flashVRStatus("VR: A√ßƒ±ldƒ± ‚úÖ");

      // Keep UI buttons in sync
      syncVRHudButtons();
      updateView();
    }

    function exitVR(){
      if (!gameState.vrActive) return;
      gameState.vrActive = false;

      document.body.classList.remove("vr-active");
      document.getElementById("vrOverlay").setAttribute("aria-hidden", "true");
      flashStatus("VR kapandƒ± ‚úÖ");

      // Clean VR clones (allow reopen cleanly)
      document.getElementById("eyeSceneL").innerHTML = "";
      document.getElementById("eyeSceneR").innerHTML = "";
      vrWorldL = null;
      vrWorldR = null;
    }

    function syncVRHudButtons(){
      const map = {
        roads: document.getElementById("vrBtnRoads"),
        water: document.getElementById("vrBtnWater"),
        settlement: document.getElementById("vrBtnSettlement"),
        risk: document.getElementById("vrBtnRisk")
      };
      Object.keys(map).forEach(k=>{
        const btn = map[k];
        if (!btn) return;
        btn.classList.toggle("inactive", !gameState.activeLayers[k]);
      });
    }

    function maybeRotateHint(){
      const hint = document.getElementById("rotateHint");
      const isPortrait = window.matchMedia("(orientation: portrait)").matches;
      if (isPortrait) hint.style.display = "flex";
    }

    /***********************
     * MOVEMENT / CONTROL (normal + VR)
     ***********************/
    function zoom(delta){
      camera.zoom = clamp(camera.zoom + delta, 0.8, 2.8);
      updateView();
    }

    function moveForward(step=10){
      // Move forward in facing direction: we simulate by zooming slightly + panning
      // forward = increase zoom a bit and pan upward in rotated frame
      camera.zoom = clamp(camera.zoom + 0.03, 0.8, 2.8);

      // Pan based on yaw (so "forward" follows direction)
      const rad = (camera.yaw * Math.PI) / 180;
      camera.x -= Math.sin(rad) * step;
      camera.y += Math.cos(rad) * step;

      updateView();
    }

    function moveBackward(step=10){
      camera.zoom = clamp(camera.zoom - 0.03, 0.8, 2.8);
      const rad = (camera.yaw * Math.PI) / 180;
      camera.x += Math.sin(rad) * step;
      camera.y -= Math.cos(rad) * step;
      updateView();
    }

    function turn(deltaDeg){
      camera.yaw = (camera.yaw + deltaDeg) % 360;
      gameState.directionsExplored++;
      if (gameState.directionsExplored >= 4 && !achievements[1].unlocked){
        unlockAchievement(2);
      }
      checkMissions();
      updateView();
    }

    function resetView(){
      camera.x = 0;
      camera.y = 0;
      camera.zoom = 1.0;
      camera.yaw = 0;
      camera.pitch = 0;
      updateView();
    }

    /***********************
     * DEVICE ORIENTATION (Head tracking-ish)
     ***********************/
    let deviceOrientationEnabled = false;
    let lastGamma = 0;
    let lastBeta = 0;

    function handleOrientation(e){
      // gamma: left/right tilt (-90..90), beta: front/back (-180..180)
      if (typeof e.gamma !== "number" || typeof e.beta !== "number") return;

      // Smooth
      const g = e.gamma;
      const b = e.beta;

      // We map gamma to yaw offset and beta to pitch
      // Use small sensitivity to avoid nausea
      const yawOffset = clamp(g, -35, 35);
      const pitch = clamp(b - 20, -25, 25); // bias a bit

      // Blend (low-pass)
      lastGamma = lastGamma * 0.85 + yawOffset * 0.15;
      lastBeta = lastBeta * 0.85 + pitch * 0.15;

      // Only apply in VR to preserve normal mode usability
      if (gameState.vrActive){
        camera.pitch = lastBeta;
        // do NOT overwrite yaw fully; instead add small "head" drift on top of base yaw
        // Here we gently steer yaw to follow head:
        camera.yaw = camera.yaw * 0.90 + lastGamma * 0.10 + (camera.yaw * 0.00);
        updateVREyes();
      }
    }

    async function enableDeviceOrientationIfNeeded(){
      if (deviceOrientationEnabled) return true;

      // iOS requires permission via user gesture sometimes
      try{
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function"){
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== "granted"){
            flashVRStatus("VR: Ba≈ü izleme izni verilmedi");
            return false;
          }
        }
        window.addEventListener("deviceorientation", handleOrientation, { passive:true });
        deviceOrientationEnabled = true;
        flashVRStatus("VR: Ba≈ü izleme aktif ‚úÖ");
        return true;
      }catch(err){
        flashVRStatus("VR: Ba≈ü izleme desteklenmiyor");
        return false;
      }
    }

    /***********************
     * BLUETOOTH GAMEPAD / KEYBOARD SUPPORT
     ***********************/
    // Many VR bluetooth remotes on iOS act like keyboard arrows/enter.
    // We'll also poll Gamepad API where possible (best-effort).
    let gamepadLoopId = null;

    function startGamepadLoop(){
      if (gamepadLoopId) return;
      const tick = ()=>{
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        const gp = pads && pads[0];
        if (gp && gameState.vrActive){
          // Axes: left stick (if any)
          const ax0 = gp.axes[0] || 0;
          const ax1 = gp.axes[1] || 0;

          if (Math.abs(ax0) > 0.35) turn(ax0 * 1.8);
          if (ax1 < -0.45) moveForward(8);
          if (ax1 > 0.45) moveBackward(8);

          // Buttons: A(0) select, B(1) exit maybe
          if (gp.buttons[0]?.pressed){
            // quick "select": toggle a focused layer? We'll just flash for now
            // Users usually use HUD buttons directly.
          }
          if (gp.buttons[1]?.pressed){
            // optional: exit VR
          }
        }
        gamepadLoopId = requestAnimationFrame(tick);
      };
      gamepadLoopId = requestAnimationFrame(tick);
    }

    function stopGamepadLoop(){
      if (gamepadLoopId){
        cancelAnimationFrame(gamepadLoopId);
        gamepadLoopId = null;
      }
    }

    document.addEventListener("keydown", (e)=>{
      const k = e.key;

      // Global shortcuts
      if (k.toLowerCase() === "v"){
        e.preventDefault();
        if (gameState.vrActive) exitVR(); else enterVR();
        return;
      }

      // Layers toggles 1..5 (topo is 1 but always on)
      if (k === "2"){ e.preventDefault(); toggleLayer("roads"); return; }
      if (k === "3"){ e.preventDefault(); toggleLayer("water"); return; }
      if (k === "4"){ e.preventDefault(); toggleLayer("settlement"); return; }
      if (k === "5"){ e.preventDefault(); toggleLayer("risk"); return; }

      // Movement / view
      if (k === "ArrowUp"){ e.preventDefault(); moveForward(12); return; }
      if (k === "ArrowDown"){ e.preventDefault(); moveBackward(12); return; }
      if (k === "ArrowLeft"){ e.preventDefault(); turn(-6); return; }
      if (k === "ArrowRight"){ e.preventDefault(); turn(6); return; }
      if (k === "+" || k === "="){ e.preventDefault(); zoom(+0.08); return; }
      if (k === "-" || k === "_"){ e.preventDefault(); zoom(-0.08); return; }
      if (k === "Escape"){ if (gameState.vrActive){ e.preventDefault(); exitVR(); } return; }
      if (k === "Enter" || k === " "){
        // "Select" - in VR it can toggle currently highlighted layer if you want
        // We'll keep it as no-op (reticle clicks are hard without raycast).
        // But it still works for focusing buttons in iOS if remote sends enter on focused control.
      }
    }, { passive:false });

    /***********************
     * UI: MISSIONS / ACH / QUIZ
     ***********************/
    function renderMissions(){
      const el = document.getElementById("missions");
      el.innerHTML = missions.map(m=>{
        const statusIcon = m.status === "locked" ? "üîí" : (m.status === "active" ? "‚ö°" : "‚úÖ");
        return `
          <div class="mission-card ${m.status}">
            <div class="mission-title">${statusIcon} ${m.title}</div>
            <div class="mission-desc">${m.desc}</div>
            <div class="mission-reward">+${m.reward} puan</div>
          </div>
        `;
      }).join("");
    }

    function renderAchievements(){
      const el = document.getElementById("achievements");
      el.innerHTML = achievements.map(a=>`
        <div class="achievement ${a.unlocked ? "unlocked":""}">
          <div class="achievement-icon">${a.icon}</div>
          <div class="achievement-name">${a.name}</div>
          <div class="achievement-desc">${a.desc}</div>
        </div>
      `).join("");
    }

    function renderQuiz(){
      const el = document.getElementById("quiz");
      el.innerHTML = quizQuestions.map((q, i)=>`
        <div class="quiz-question">
          <div class="quiz-question-text">${i+1}. ${q.question}</div>
          <div class="quiz-options">
            ${q.options.map((opt, j)=>`
              <div class="quiz-option" data-q="${i}" data-o="${j}">${opt}</div>
            `).join("")}
          </div>
        </div>
      `).join("");

      document.querySelectorAll(".quiz-option").forEach(opt=>{
        opt.addEventListener("click", ()=>{
          const qi = opt.dataset.q;
          document.querySelectorAll(`.quiz-option[data-q="${qi}"]`).forEach(x=>x.classList.remove("selected"));
          opt.classList.add("selected");
        }, { passive:true });
      });
    }

    function addScore(points){
      gameState.score += points;
      // Level up each 200
      const newLevel = Math.floor(gameState.score / 200) + 1;
      gameState.level = Math.max(gameState.level, newLevel);

      document.getElementById("score").textContent = gameState.score;
      document.getElementById("level").textContent = gameState.level;

      if (gameState.score >= 500 && !achievements[5].unlocked) unlockAchievement(6);
    }

    function unlockAchievement(id){
      const ach = achievements.find(a=>a.id===id);
      if (!ach || ach.unlocked) return;
      ach.unlocked = true;
      renderAchievements();
      addScore(50);
    }

    function updateMissionCounter(){
      document.getElementById("missions-completed").textContent = `${gameState.completedMissions}/${missions.length}`;
    }

    function completeMission(idx){
      const m = missions[idx];
      if (m.status === "completed") return;
      m.status = "completed";
      gameState.completedMissions++;
      addScore(m.reward);

      if (gameState.completedMissions === 1 && !achievements[4].unlocked) unlockAchievement(5);

      // unlock next
      if (idx < missions.length - 1){
        missions[idx+1].status = "active";
      }
      updateMissionCounter();
      renderMissions();
    }

    function checkMissions(){
      missions.forEach((m, idx)=>{
        if (m.status === "active" && m.check()){
          completeMission(idx);
        }
        if (m.status === "locked" && idx>0 && missions[idx-1].status === "completed"){
          m.status = "active";
        }
      });
      renderMissions();
    }

    function checkQuizAnswers(){
      let correct = 0;
      quizQuestions.forEach((q, i)=>{
        const selected = document.querySelector(`.quiz-option[data-q="${i}"].selected`);
        const all = document.querySelectorAll(`.quiz-option[data-q="${i}"]`);
        all.forEach(x=>{ x.classList.remove("correct","wrong"); });

        if (selected){
          const sel = parseInt(selected.dataset.o, 10);
          all.forEach(x=>{
            const oi = parseInt(x.dataset.o, 10);
            if (oi === q.correct) x.classList.add("correct");
            else if (x.classList.contains("selected")) x.classList.add("wrong");
          });
          if (sel === q.correct) correct++;
        }
      });

      const pct = (correct / quizQuestions.length) * 100;
      const res = document.getElementById("quizResult");
      res.classList.remove("hidden");
      document.getElementById("quizScore").textContent = `${correct}/${quizQuestions.length}`;

      if (pct >= 80){
        document.getElementById("quizMsg").textContent = "M√ºkemmel! Harita okuryazarlƒ±ƒüƒ±nda ustasƒ±n! üèÜ";
        addScore(200);
        if (!achievements[6].unlocked) unlockAchievement(7);
      } else if (pct >= 60){
        document.getElementById("quizMsg").textContent = "ƒ∞yi! Geli≈ümeye devam! üëç";
        addScore(150);
      } else {
        document.getElementById("quizMsg").textContent = "Daha fazla pratik yapmalƒ±sƒ±n! üí™";
        addScore(100);
      }

      gameState.quizCompleted = true;
      checkMissions();
      document.getElementById("checkAnswers").disabled = true;
    }

    /***********************
     * STATUS MESSAGES
     ***********************/
    let statusTimer = null;
    function flashStatus(msg){
      const box = document.getElementById("currentTask");
      const title = box.querySelector(".task-prompt-title");
      const desc  = box.querySelector(".task-prompt-desc");
      title.textContent = "Bilgi";
      desc.textContent = msg;
      if (statusTimer) clearTimeout(statusTimer);
      statusTimer = setTimeout(()=>{
        title.textContent = "Ho≈ü geldiniz!";
        desc.textContent =
          "Topografya hep a√ßƒ±k. Diƒüer katmanlarƒ± butonlardan a√ß/kapa yapƒ±n. VR modda ba≈üƒ±nƒ±zƒ± √ßevirip haritayƒ± gezin, ileri/geri ile yakla≈üƒ±n. (Kumanda/klavye: 1..5 katman, ‚Üë‚Üì ileri/geri, ‚Üê‚Üí d√∂n, +/- zoom, V VR)";
      }, 1800);
    }

    let vrStatusTimer = null;
    function flashVRStatus(msg){
      const el = document.getElementById("vrStatus");
      el.textContent = msg;
      if (vrStatusTimer) clearTimeout(vrStatusTimer);
      vrStatusTimer = setTimeout(()=>{
        el.textContent = "VR: Hazƒ±r";
      }, 1600);
    }

    /***********************
     * EVENTS
     ***********************/
    function init(){
      // Render panels
      renderMissions();
      renderAchievements();
      renderQuiz();

      // Layer buttons
      document.querySelectorAll(".layer-btn").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          toggleLayer(btn.dataset.layer);
        }, { passive:true });
      });

      // Zoom/reset
      document.getElementById("zoomIn").addEventListener("click", ()=> zoom(+0.10), { passive:true });
      document.getElementById("zoomOut").addEventListener("click", ()=> zoom(-0.10), { passive:true });
      document.getElementById("resetView").addEventListener("click", ()=> resetView(), { passive:true });

      // VR button
      document.getElementById("vrBtn").addEventListener("click", async ()=>{
        if (!gameState.vrActive){
          enterVR();
          await enableDeviceOrientationIfNeeded();
          startGamepadLoop();
        } else {
          exitVR();
          stopGamepadLoop();
        }
      }, { passive:false });

      // VR exit
      document.getElementById("vrExit").addEventListener("click", ()=>{
        exitVR();
        stopGamepadLoop();
      }, { passive:true });

      // VR HUD layer toggles
      document.querySelectorAll(".hudPill[data-vrlayer]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const layer = btn.getAttribute("data-vrlayer");
          toggleLayer(layer);
          syncVRHudButtons();
          // also sync VR clones if active
          if (gameState.vrActive) syncAllLayersToVR();
        }, { passive:true });
      });

      // VR zoom
      document.getElementById("vrZoomIn").addEventListener("click", ()=> zoom(+0.10), { passive:true });
      document.getElementById("vrZoomOut").addEventListener("click", ()=> zoom(-0.10), { passive:true });

      // VR movement
      let moveInterval = null;
      function startHold(fn){
        fn();
        moveInterval = setInterval(fn, 80);
      }
      function stopHold(){
        if (moveInterval){ clearInterval(moveInterval); moveInterval = null; }
      }

      const fwd = document.getElementById("moveFwd");
      const back = document.getElementById("moveBack");
      const left = document.getElementById("turnLeft");
      const right = document.getElementById("turnRight");

      // Touch/mouse hold support
      const holdable = [
        [fwd, ()=> moveForward(10)],
        [back, ()=> moveBackward(10)],
        [left, ()=> turn(-4)],
        [right, ()=> turn(4)]
      ];
      holdable.forEach(([el, fn])=>{
        el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); startHold(fn); }, { passive:false });
        el.addEventListener("pointerup", stopHold, { passive:true });
        el.addEventListener("pointercancel", stopHold, { passive:true });
        el.addEventListener("pointerleave", stopHold, { passive:true });
      });

      document.getElementById("vrReset").addEventListener("click", ()=> resetView(), { passive:true });

      // Rotate hint dismiss
      document.getElementById("hideRotateHint").addEventListener("click", ()=>{
        document.getElementById("rotateHint").style.display = "none";
      }, { passive:true });

      // BEP
      document.getElementById("bepBtn").addEventListener("click", ()=>{
        gameState.bepMode = !gameState.bepMode;
        document.body.classList.toggle("bep-mode");
        const b = document.getElementById("bepBtn");
        b.textContent = gameState.bepMode ? "Normal Mod" : "BEP Modu";
      }, { passive:true });

      // Quiz check
      document.getElementById("checkAnswers").addEventListener("click", checkQuizAnswers, { passive:true });

      // Initialize stats
      document.getElementById("score").textContent = gameState.score;
      document.getElementById("level").textContent = gameState.level;
      updateMissionCounter();

      // initial view
      updateView();

      // Resize/orientation changes
      window.addEventListener("orientationchange", ()=>{
        if (gameState.vrActive) maybeRotateHint();
      });
      window.addEventListener("resize", ()=>{
        if (gameState.vrActive) maybeRotateHint();
      });
    }

    /***********************
     * Keep VR clones synced when toggling layers in normal controls
     ***********************/
    function hookLayerSync(){
      const originalToggle = toggleLayer;
      // already calls sync if needed in VR hud; also add here:
    }

    // Patch: whenever normal layer toggled, ensure VR clones reflect it
    const _toggleLayer = toggleLayer;
    toggleLayer = function(layerKey){
      _toggleLayer(layerKey);
      syncVRHudButtons();
      if (gameState.vrActive) syncAllLayersToVR();
    };

    init();
  </script>
</body>
</html>
